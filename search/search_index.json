{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue chez ipein info Nous sommes ravis de vous accueillir sur notre site. Chez ipein info, nous sommes passionn\u00e9s par l'informatique. def hello(): print(\"Bienvenue chez ipein info !\") T\u00e9l\u00e9charger le Programme officiel d'informatique Programme Info 2 \u00e8me ann\u00e9e Rappel Les structures de donn\u00e9es avanc\u00e9es : Piles et Files Programmation Orient\u00e9e Objet Les Bases de Donn\u00e9es (SQLite) Simulation num\u00e9rique N'h\u00e9sitez pas \u00e0 explorer notre site pour d\u00e9couvrir tout ce que nous avons \u00e0 offrir. Si vous avez des questions ou avez besoin d'aide, n'h\u00e9sitez pas \u00e0 nous contacter. Nous sommes l\u00e0 pour vous aider \u00e0 r\u00e9ussir. Notre objectif est de fournir des informations utiles et informatives. Si vous trouvez notre site utile, nous serions reconnaissants si vous pouviez prendre un moment pour montrer votre soutien en donnant une \u00e9toile \u00e0 notre repository GitHub. C'est simple, il vous suffit de cliquer sur le bouton \"Star\" en haut \u00e0 droite de la page. La r\u00e9ussite au concours est \u00e0 port\u00e9e de main. Pers\u00e9v\u00e9rez ! \ud83c\udf1f\ud83d\udcaa","title":"Accueil"},{"location":"#bienvenue-chez-ipein-info","text":"Nous sommes ravis de vous accueillir sur notre site. Chez ipein info, nous sommes passionn\u00e9s par l'informatique. def hello(): print(\"Bienvenue chez ipein info !\") T\u00e9l\u00e9charger le Programme officiel d'informatique","title":"Bienvenue chez ipein info"},{"location":"#programme-info-2eme-annee","text":"Rappel Les structures de donn\u00e9es avanc\u00e9es : Piles et Files Programmation Orient\u00e9e Objet Les Bases de Donn\u00e9es (SQLite) Simulation num\u00e9rique N'h\u00e9sitez pas \u00e0 explorer notre site pour d\u00e9couvrir tout ce que nous avons \u00e0 offrir. Si vous avez des questions ou avez besoin d'aide, n'h\u00e9sitez pas \u00e0 nous contacter. Nous sommes l\u00e0 pour vous aider \u00e0 r\u00e9ussir. Notre objectif est de fournir des informations utiles et informatives. Si vous trouvez notre site utile, nous serions reconnaissants si vous pouviez prendre un moment pour montrer votre soutien en donnant une \u00e9toile \u00e0 notre repository GitHub. C'est simple, il vous suffit de cliquer sur le bouton \"Star\" en haut \u00e0 droite de la page. La r\u00e9ussite au concours est \u00e0 port\u00e9e de main. Pers\u00e9v\u00e9rez ! \ud83c\udf1f\ud83d\udcaa","title":"Programme Info 2\u00e8me ann\u00e9e"},{"location":"BD/contraintes-sql/","text":"Contraintes SQL Contrainte CHECK En SQL, la contrainte CHECK est utilis\u00e9e pour sp\u00e9cifier une condition qui doit \u00eatre satisfaite pour chaque ligne d'une table. Examples: -- Assure que l'\u00e2ge est compris entre 18 et 99 Age INT CHECK (Age >= 18 AND Age <= 99) -- Assure que le genre doit \u00eatre 'H' (pour Homme) ou 'F' (pour Femme) Genre CHAR(1) CHECK (Genre IN ('H', 'F')) -- Assure que le prix n'est pas sup\u00e9rieur \u00e0 la moyenne des prix de tous les produits Prix DECIMAL(10, 2) CHECK (Prix <= (SELECT AVG(Prix) FROM Produits)) -- Assure que la date de l'\u00e9v\u00e9nement est dans la plage sp\u00e9cifi\u00e9e EventDate DATE CHECK (EventDate >= '2024-01-01' AND EventDate <= '2024-12-31') -- Assure que l'email suit un format basique d'email Email VARCHAR(100) CHECK (Email LIKE '%@%.%') -- Assure que IsCompleted est soit 0, soit 1 (valeurs bool\u00e9ennes) IsCompleted BOOLEAN CHECK (IsCompleted IN (0, 1)) -- Limite la longueur du texte \u00e0 255 caract\u00e8res Text VARCHAR(255) CHECK (LENGTH(Text) <= 255) -- Assure que PrixTotal est \u00e9gal au produit de deux colonnes Quantite et Prix PrixTotal DECIMAL(10, 2) CHECK (PrixTotal = Quantite * Prix) -- Assure que Points sont entre 0 et 100 ou peuvent \u00eatre NULL Points INT CHECK (Points >= 0 AND Points <= 100 OR Points IS NULL) Contrainte DEFAULT En SQL, la contrainte DEFAULT est utilis\u00e9e pour sp\u00e9cifier une valeur par d\u00e9faut pour une colonne lorsque aucune valeur n'est fournie lors de l'insertion d'une nouvelle ligne. Examples: Status VARCHAR(20) DEFAULT 'En attente' Salaire DECIMAL(10, 2) DEFAULT 5000.00 -- CURRENT_DATE est la date actuelle DateEcheance DATE DEFAULT CURRENT_DATE -- CURRENT_TIMESTAMP est la date et l'heure actuelles DateAjout TIMESTAMP DEFAULT CURRENT_TIMESTAMP Moyenne FLOAT DEFAULT ((Note1 + Note2) / 2) EstActif BOOLEAN DEFAULT TRUE La fonction CURRENT_TIMESTAMP en SQL est utilis\u00e9e pour obtenir la date et l'heure actuelles du syst\u00e8me au moment de l'ex\u00e9cution de la requ\u00eate ou de l'instruction SQL. Cela inclut la date, l'heure, les minutes, les secondes et parfois m\u00eame les fractions de seconde, selon la pr\u00e9cision du syst\u00e8me. Le terme \"timestamp\" est une combinaison des mots \"time\" (temps) et \"stamp\" (marque), ce qui signifie essentiellement une marque de temps. En informatique et en bases de donn\u00e9es, un timestamp est une valeur qui repr\u00e9sente un point sp\u00e9cifique dans le temps. Ainsi, CURRENT_TIMESTAMP fournit une marque de temps actuelle au moment o\u00f9 la requ\u00eate SQL est ex\u00e9cut\u00e9e.","title":"Contraintes SQL"},{"location":"BD/contraintes-sql/#contraintes-sql","text":"","title":"Contraintes SQL"},{"location":"BD/contraintes-sql/#contrainte-check","text":"En SQL, la contrainte CHECK est utilis\u00e9e pour sp\u00e9cifier une condition qui doit \u00eatre satisfaite pour chaque ligne d'une table.","title":"Contrainte CHECK"},{"location":"BD/contraintes-sql/#examples","text":"-- Assure que l'\u00e2ge est compris entre 18 et 99 Age INT CHECK (Age >= 18 AND Age <= 99) -- Assure que le genre doit \u00eatre 'H' (pour Homme) ou 'F' (pour Femme) Genre CHAR(1) CHECK (Genre IN ('H', 'F')) -- Assure que le prix n'est pas sup\u00e9rieur \u00e0 la moyenne des prix de tous les produits Prix DECIMAL(10, 2) CHECK (Prix <= (SELECT AVG(Prix) FROM Produits)) -- Assure que la date de l'\u00e9v\u00e9nement est dans la plage sp\u00e9cifi\u00e9e EventDate DATE CHECK (EventDate >= '2024-01-01' AND EventDate <= '2024-12-31') -- Assure que l'email suit un format basique d'email Email VARCHAR(100) CHECK (Email LIKE '%@%.%') -- Assure que IsCompleted est soit 0, soit 1 (valeurs bool\u00e9ennes) IsCompleted BOOLEAN CHECK (IsCompleted IN (0, 1)) -- Limite la longueur du texte \u00e0 255 caract\u00e8res Text VARCHAR(255) CHECK (LENGTH(Text) <= 255) -- Assure que PrixTotal est \u00e9gal au produit de deux colonnes Quantite et Prix PrixTotal DECIMAL(10, 2) CHECK (PrixTotal = Quantite * Prix) -- Assure que Points sont entre 0 et 100 ou peuvent \u00eatre NULL Points INT CHECK (Points >= 0 AND Points <= 100 OR Points IS NULL)","title":"Examples:"},{"location":"BD/contraintes-sql/#contrainte-default","text":"En SQL, la contrainte DEFAULT est utilis\u00e9e pour sp\u00e9cifier une valeur par d\u00e9faut pour une colonne lorsque aucune valeur n'est fournie lors de l'insertion d'une nouvelle ligne.","title":"Contrainte DEFAULT"},{"location":"BD/contraintes-sql/#examples_1","text":"Status VARCHAR(20) DEFAULT 'En attente' Salaire DECIMAL(10, 2) DEFAULT 5000.00 -- CURRENT_DATE est la date actuelle DateEcheance DATE DEFAULT CURRENT_DATE -- CURRENT_TIMESTAMP est la date et l'heure actuelles DateAjout TIMESTAMP DEFAULT CURRENT_TIMESTAMP Moyenne FLOAT DEFAULT ((Note1 + Note2) / 2) EstActif BOOLEAN DEFAULT TRUE La fonction CURRENT_TIMESTAMP en SQL est utilis\u00e9e pour obtenir la date et l'heure actuelles du syst\u00e8me au moment de l'ex\u00e9cution de la requ\u00eate ou de l'instruction SQL. Cela inclut la date, l'heure, les minutes, les secondes et parfois m\u00eame les fractions de seconde, selon la pr\u00e9cision du syst\u00e8me. Le terme \"timestamp\" est une combinaison des mots \"time\" (temps) et \"stamp\" (marque), ce qui signifie essentiellement une marque de temps. En informatique et en bases de donn\u00e9es, un timestamp est une valeur qui repr\u00e9sente un point sp\u00e9cifique dans le temps. Ainsi, CURRENT_TIMESTAMP fournit une marque de temps actuelle au moment o\u00f9 la requ\u00eate SQL est ex\u00e9cut\u00e9e.","title":"Examples:"},{"location":"BD/plan/","text":"Introduction aux Bases de Donn\u00e9es, Alg\u00e8bre Relationnelle et SQLite en Python Objectif de ce chapitre Ce chapitre vise \u00e0 introduire les concepts fondamentaux des bases de donn\u00e9es, de l'alg\u00e8bre relationnelle, et \u00e0 expliquer comment utiliser SQLite en Python. Nous explorerons la cr\u00e9ation de bases de donn\u00e9es, les requ\u00eates SQL, et la manipulation de donn\u00e9es \u00e0 l'aide de SQLite dans l'environnement Python. Contenu du Cours Le cours sur les bases de donn\u00e9es, l'alg\u00e8bre relationnelle et SQLite sera divis\u00e9 en trois parties, chacune couvrant un aspect essentiel de la gestion des donn\u00e9es. Partie 1 : Introduction aux Bases de Donn\u00e9es et \u00e0 l'Alg\u00e8bre Relationnelle Introduction aux Bases de Donn\u00e9es.pdf Cours Alg\u00e8bre Relationnelle.pdf Corrig\u00e9 des exercices du cours : Corrig\u00e9 AR.pdf Partie 2 : Transition de l'Alg\u00e8bre Relationnelle au langage SQL Cours de l'Alg\u00e8bre relationnelle \u00e0 SQL.pdf Corrig\u00e9 des exercices du cours : Corrig\u00e9 AR-SQL.pdf Partie 3 : Requ\u00eates SQL Avanc\u00e9es et utilisation de SQLite en Python SQL-SQLite.pdf Requete Select.pdf Corrig\u00e9 des exercices du cours : Corrig\u00e9 SQL-SQLite.pdf Exemple d'utilisation de SQL avec SQLite-Python.py Vous pouvez manipuler une base donn\u00e9es SQLite avec l'outil DB Browser For SQLite de deux mani\u00e8res M\u00e9thode 1 : Utiliser le fichier de base de donn\u00e9es d'extension .db qui contient les tables cr\u00e9\u00e9es et remplies. T\u00e9l\u00e9charger le fichier employes.db Lancer l'outil DB Browser For Sqlite Menu File / open Database choisir le fichier employes.db Ouvrir l'anglet \"Execute SQL\" et commencer \u00e0 taper et tester des commandes SQL. M\u00e9thode 2 : Cr\u00e9er vous-m\u00eame la base de donn\u00e9es, cr\u00e9er les tables et les remplir. T\u00e9l\u00e9charger le fichier employes.sql Ouvrir le logiciel BD Browser for SQLite Cr\u00e9er une nouvelle base de donn\u00e9es: Menu File / New DataBase tapez le nom de la base de donn\u00e9es, par exemple: ma_base.db Une fen\u00eatre s'ouvre automatiquement pour cr\u00e9er la premi\u00e8re table, Fermez la. Ouvrir l'anglet \"Execute SQL\" Copier/coller le contenu de fichier employes.sql dans la zone de texte reserv\u00e9e \u00e0 la cr\u00e9ation du code SQL. Cliquez sur la fl\u00e8che pour ex\u00e9cuter ce code SQL permettant ainsi de cr\u00e9er toutes les tables et les remplir. Vous pouvez maintenant essayer les requ\u00eates SQL vues en classe et r\u00e9pondre \u00e0 d'autres questions que vous imaginez.","title":"Plan du cours"},{"location":"BD/plan/#introduction-aux-bases-de-donnees-algebre-relationnelle-et-sqlite-en-python","text":"","title":"Introduction aux Bases de Donn\u00e9es, Alg\u00e8bre Relationnelle et SQLite en Python"},{"location":"BD/plan/#objectif-de-ce-chapitre","text":"Ce chapitre vise \u00e0 introduire les concepts fondamentaux des bases de donn\u00e9es, de l'alg\u00e8bre relationnelle, et \u00e0 expliquer comment utiliser SQLite en Python. Nous explorerons la cr\u00e9ation de bases de donn\u00e9es, les requ\u00eates SQL, et la manipulation de donn\u00e9es \u00e0 l'aide de SQLite dans l'environnement Python.","title":"Objectif de ce chapitre"},{"location":"BD/plan/#contenu-du-cours","text":"Le cours sur les bases de donn\u00e9es, l'alg\u00e8bre relationnelle et SQLite sera divis\u00e9 en trois parties, chacune couvrant un aspect essentiel de la gestion des donn\u00e9es.","title":"Contenu du Cours"},{"location":"BD/plan/#partie-1-introduction-aux-bases-de-donnees-et-a-lalgebre-relationnelle","text":"Introduction aux Bases de Donn\u00e9es.pdf Cours Alg\u00e8bre Relationnelle.pdf Corrig\u00e9 des exercices du cours : Corrig\u00e9 AR.pdf","title":"Partie 1 : Introduction aux Bases de Donn\u00e9es et \u00e0 l'Alg\u00e8bre Relationnelle"},{"location":"BD/plan/#partie-2-transition-de-lalgebre-relationnelle-au-langage-sql","text":"Cours de l'Alg\u00e8bre relationnelle \u00e0 SQL.pdf Corrig\u00e9 des exercices du cours : Corrig\u00e9 AR-SQL.pdf","title":"Partie 2 : Transition de l'Alg\u00e8bre Relationnelle au langage SQL"},{"location":"BD/plan/#partie-3-requetes-sql-avancees-et-utilisation-de-sqlite-en-python","text":"SQL-SQLite.pdf Requete Select.pdf Corrig\u00e9 des exercices du cours : Corrig\u00e9 SQL-SQLite.pdf Exemple d'utilisation de SQL avec SQLite-Python.py Vous pouvez manipuler une base donn\u00e9es SQLite avec l'outil DB Browser For SQLite de deux mani\u00e8res M\u00e9thode 1 : Utiliser le fichier de base de donn\u00e9es d'extension .db qui contient les tables cr\u00e9\u00e9es et remplies. T\u00e9l\u00e9charger le fichier employes.db Lancer l'outil DB Browser For Sqlite Menu File / open Database choisir le fichier employes.db Ouvrir l'anglet \"Execute SQL\" et commencer \u00e0 taper et tester des commandes SQL. M\u00e9thode 2 : Cr\u00e9er vous-m\u00eame la base de donn\u00e9es, cr\u00e9er les tables et les remplir. T\u00e9l\u00e9charger le fichier employes.sql Ouvrir le logiciel BD Browser for SQLite Cr\u00e9er une nouvelle base de donn\u00e9es: Menu File / New DataBase tapez le nom de la base de donn\u00e9es, par exemple: ma_base.db Une fen\u00eatre s'ouvre automatiquement pour cr\u00e9er la premi\u00e8re table, Fermez la. Ouvrir l'anglet \"Execute SQL\" Copier/coller le contenu de fichier employes.sql dans la zone de texte reserv\u00e9e \u00e0 la cr\u00e9ation du code SQL. Cliquez sur la fl\u00e8che pour ex\u00e9cuter ce code SQL permettant ainsi de cr\u00e9er toutes les tables et les remplir. Vous pouvez maintenant essayer les requ\u00eates SQL vues en classe et r\u00e9pondre \u00e0 d'autres questions que vous imaginez.","title":"Partie 3 : Requ\u00eates SQL Avanc\u00e9es et utilisation de SQLite en Python"},{"location":"SimulNum/plan/","text":"La Simulation Num\u00e9rique Objectif de ce chapitre Ce chapitre a pour objectif d'introduire les aspects fondamentaux de la simulation num\u00e9rique en utilisant Python. Nous explorerons plusieurs domaines, notamment l'alg\u00e8bre lin\u00e9aire avec les biblioth\u00e8ques Numpy et Matplotlib, la cryptographie, le traitement d'images, et l'interpolation de Lagrange. Avant de commencer Assurez-vous d'avoir les biblioth\u00e8ques n\u00e9cessaires install\u00e9es dans votre environnement Python, telles que Numpy et Matplotlib pour pouvoir ex\u00e9cuter les exemples de code. Installation de Numpy et Matplotlib T\u00e9l\u00e9chargez et installez Python depuis python.org en s\u00e9lectionnant l'option \"Add Python to PATH\" lors de l'installation. Ouvrez une fen\u00eatre de commandes (cmd) et ex\u00e9cutez les commandes suivantes: pip install numpy pip install matplotlib Contenu du Cours Le cours sur la simulation num\u00e9rique couvrira plusieurs parties : Partie 1 : Alg\u00e8bre Lin\u00e9aire L'essentiel de Numpy et Matplotlib.pdf Cours Numpy et Matplotlib.pdf TD1 Numpy et Matplotlib.pdf R\u00e9solution de Syst\u00e8mes Lin\u00e9aires.pdf Pivot de Gauss.pdf Pivot de Gauss Corrig\u00e9.pdf Partie 2 : Cryptographie TD Cryptographie.pdf TD Cryptographie Corrig\u00e9.pdf Partie 3 : Traitement d'Images Cours et TD traitement images.pdf TD traitement images Corrig\u00e9.pdf Partie 4 : Interpolation de Lagrange Cours et TD Interpolation de Lagrange.pdf TD Interpolation de Lagrange Corrig\u00e9 pdf | .py","title":"Plan du cours"},{"location":"SimulNum/plan/#la-simulation-numerique","text":"","title":"La Simulation Num\u00e9rique"},{"location":"SimulNum/plan/#objectif-de-ce-chapitre","text":"Ce chapitre a pour objectif d'introduire les aspects fondamentaux de la simulation num\u00e9rique en utilisant Python. Nous explorerons plusieurs domaines, notamment l'alg\u00e8bre lin\u00e9aire avec les biblioth\u00e8ques Numpy et Matplotlib, la cryptographie, le traitement d'images, et l'interpolation de Lagrange.","title":"Objectif de ce chapitre"},{"location":"SimulNum/plan/#avant-de-commencer","text":"Assurez-vous d'avoir les biblioth\u00e8ques n\u00e9cessaires install\u00e9es dans votre environnement Python, telles que Numpy et Matplotlib pour pouvoir ex\u00e9cuter les exemples de code.","title":"Avant de commencer"},{"location":"SimulNum/plan/#installation-de-numpy-et-matplotlib","text":"T\u00e9l\u00e9chargez et installez Python depuis python.org en s\u00e9lectionnant l'option \"Add Python to PATH\" lors de l'installation. Ouvrez une fen\u00eatre de commandes (cmd) et ex\u00e9cutez les commandes suivantes: pip install numpy pip install matplotlib","title":"Installation de Numpy et Matplotlib"},{"location":"SimulNum/plan/#contenu-du-cours","text":"Le cours sur la simulation num\u00e9rique couvrira plusieurs parties :","title":"Contenu du Cours"},{"location":"SimulNum/plan/#partie-1-algebre-lineaire","text":"L'essentiel de Numpy et Matplotlib.pdf Cours Numpy et Matplotlib.pdf TD1 Numpy et Matplotlib.pdf R\u00e9solution de Syst\u00e8mes Lin\u00e9aires.pdf Pivot de Gauss.pdf Pivot de Gauss Corrig\u00e9.pdf","title":"Partie 1 : Alg\u00e8bre Lin\u00e9aire"},{"location":"SimulNum/plan/#partie-2-cryptographie","text":"TD Cryptographie.pdf TD Cryptographie Corrig\u00e9.pdf","title":"Partie 2 : Cryptographie"},{"location":"SimulNum/plan/#partie-3-traitement-dimages","text":"Cours et TD traitement images.pdf TD traitement images Corrig\u00e9.pdf","title":"Partie 3 : Traitement d'Images"},{"location":"SimulNum/plan/#partie-4-interpolation-de-lagrange","text":"Cours et TD Interpolation de Lagrange.pdf TD Interpolation de Lagrange Corrig\u00e9 pdf | .py","title":"Partie 4 : Interpolation de Lagrange"},{"location":"aide/about/","text":"\u00c0 Propos de Ipein Info Nous sommes l\u00e0 pour vous aider \u00e0 exceller dans vos \u00e9tudes. Si vous avez des questions ou avez besoin d'assistance, n'h\u00e9sitez pas \u00e0 me contacter \u00e0 l'adresse suivante : anis_saied@hotmail.com . Notre objectif est de fournir des informations utiles et informatives. Si vous trouvez notre site utile, nous serions reconnaissants si vous pouviez prendre un moment pour montrer votre soutien en donnant une \u00e9toile \u00e0 notre repository GitHub. C'est simple, il vous suffit de cliquer sur le bouton \"Star\" en haut \u00e0 droite de la page. Bon travail! \ud83d\udc4f","title":"A propos"},{"location":"aide/about/#a-propos-de-ipein-info","text":"Nous sommes l\u00e0 pour vous aider \u00e0 exceller dans vos \u00e9tudes. Si vous avez des questions ou avez besoin d'assistance, n'h\u00e9sitez pas \u00e0 me contacter \u00e0 l'adresse suivante : anis_saied@hotmail.com . Notre objectif est de fournir des informations utiles et informatives. Si vous trouvez notre site utile, nous serions reconnaissants si vous pouviez prendre un moment pour montrer votre soutien en donnant une \u00e9toile \u00e0 notre repository GitHub. C'est simple, il vous suffit de cliquer sur le bouton \"Star\" en haut \u00e0 droite de la page. Bon travail! \ud83d\udc4f","title":"\u00c0 Propos de Ipein Info"},{"location":"aide/tools/","text":"Outils Utilitaires en Python Bienvenue sur la page des outils utilitaires en Python, une ressource qui regroupe des liens vers des ressources, des biblioth\u00e8ques essentielles, et des cheatsheets (aide-m\u00e9moire) pour vous aider \u00e0 ma\u00eetriser Python et \u00e0 devenir un programmeur plus efficace. Explorez, apprenez et profitez de votre voyage dans le monde de Python ! Ressources d'Apprentissage Python.org : Le site officiel de Python, qui propose une documentation compl\u00e8te, des tutoriels et des guides pour apprendre Python. Real Python : Une plateforme d'apprentissage en ligne qui propose des articles, des cours et des projets pratiques pour les programmeurs Python de tous niveaux. Learn Python : Un site Web interactif qui vous permet d'apprendre Python en pratiquant directement dans le navigateur. Cheatsheets Cheatsheet (aide-m\u00e9moire, aide-m\u00e9moires) : est un abr\u00e9g\u00e9 donnant l'essentiel d'une mati\u00e8re, d'un programme, en particulier en vue d'un examen. Python Cheatsheet : Une cheatsheet compl\u00e8te avec des exemples de code pour diff\u00e9rents aspects de Python. NumPy Cheatsheet : Une cheatsheet pour NumPy avec les commandes les plus courantes. Python Cheat Sheet : Une cheatsheet compl\u00e8te pour Python, couvrant les bases du langage ainsi que des sujets avanc\u00e9s. Python Crash Course Cheat Sheets (en PDF ): Une collection de cheatsheets bas\u00e9es sur le livre \"Python Crash Course\" qui couvre divers aspects de Python. Python Basics Cheat Sheet : Un aide-m\u00e9moire de base pour les concepts fondamentaux de Python. Python String Methods Cheat Sheet : Une cheatsheet qui r\u00e9sume les m\u00e9thodes de manipulation de cha\u00eenes de caract\u00e8res en Python. NumPy Cheat Sheet : Une cheatsheet pour NumPy, une biblioth\u00e8que essentielle pour le calcul num\u00e9rique en Python. Matplotlib Cheat Sheet : Des cheatsheets officielles de Matplotlib pour vous aider \u00e0 cr\u00e9er des graphiques en Python. Ces aides-m\u00e9moire couvrent une gamme de sujets en Python, de l'apprentissage des bases aux sujets plus avanc\u00e9s. Vous pouvez les utiliser comme r\u00e9f\u00e9rences rapides pendant votre apprentissage et votre d\u00e9veloppement en Python. Biblioth\u00e8ques et outils NumPy NumPy est une biblioth\u00e8que puissante pour la manipulation de tableaux multidimensionnels et de donn\u00e9es num\u00e9riques. Il est largement utilis\u00e9 dans le domaine de la science des donn\u00e9es et de l'analyse num\u00e9rique. Matplotlib Matplotlib est une biblioth\u00e8que pour la cr\u00e9ation de graphiques et de visualisations de donn\u00e9es en 2D et 3D. Elle est tr\u00e8s utile pour la repr\u00e9sentation graphique des donn\u00e9es. Visual Studio Code (VS Code) Visual Studio Code est un \u00e9diteur de code open-source d\u00e9velopp\u00e9 par Microsoft. Il prend en charge le d\u00e9veloppement Python avec des extensions utiles, telles que Python et Jupyter. pip pip est le gestionnaire de paquets Python par d\u00e9faut. Il vous permet d'installer et de g\u00e9rer des biblioth\u00e8ques tierces. Repl.it Repl.it est une plateforme en ligne qui vous permet d'\u00e9crire, d'ex\u00e9cuter et de partager du code Python dans votre navigateur sans avoir \u00e0 installer quoi que ce soit sur votre ordinateur. Ces outils utilitaires en Python sont l\u00e0 pour vous aider dans votre apprentissage et votre d\u00e9veloppement en Python. N'h\u00e9sitez pas \u00e0 les explorer et \u00e0 les utiliser pour r\u00e9soudre des probl\u00e8mes, automatiser des t\u00e2ches et r\u00e9aliser des projets passionnants.","title":"Utilitaires"},{"location":"aide/tools/#outils-utilitaires-en-python","text":"Bienvenue sur la page des outils utilitaires en Python, une ressource qui regroupe des liens vers des ressources, des biblioth\u00e8ques essentielles, et des cheatsheets (aide-m\u00e9moire) pour vous aider \u00e0 ma\u00eetriser Python et \u00e0 devenir un programmeur plus efficace. Explorez, apprenez et profitez de votre voyage dans le monde de Python !","title":"Outils Utilitaires en Python"},{"location":"aide/tools/#ressources-dapprentissage","text":"Python.org : Le site officiel de Python, qui propose une documentation compl\u00e8te, des tutoriels et des guides pour apprendre Python. Real Python : Une plateforme d'apprentissage en ligne qui propose des articles, des cours et des projets pratiques pour les programmeurs Python de tous niveaux. Learn Python : Un site Web interactif qui vous permet d'apprendre Python en pratiquant directement dans le navigateur.","title":"Ressources d'Apprentissage"},{"location":"aide/tools/#cheatsheets","text":"Cheatsheet (aide-m\u00e9moire, aide-m\u00e9moires) : est un abr\u00e9g\u00e9 donnant l'essentiel d'une mati\u00e8re, d'un programme, en particulier en vue d'un examen. Python Cheatsheet : Une cheatsheet compl\u00e8te avec des exemples de code pour diff\u00e9rents aspects de Python. NumPy Cheatsheet : Une cheatsheet pour NumPy avec les commandes les plus courantes. Python Cheat Sheet : Une cheatsheet compl\u00e8te pour Python, couvrant les bases du langage ainsi que des sujets avanc\u00e9s. Python Crash Course Cheat Sheets (en PDF ): Une collection de cheatsheets bas\u00e9es sur le livre \"Python Crash Course\" qui couvre divers aspects de Python. Python Basics Cheat Sheet : Un aide-m\u00e9moire de base pour les concepts fondamentaux de Python. Python String Methods Cheat Sheet : Une cheatsheet qui r\u00e9sume les m\u00e9thodes de manipulation de cha\u00eenes de caract\u00e8res en Python. NumPy Cheat Sheet : Une cheatsheet pour NumPy, une biblioth\u00e8que essentielle pour le calcul num\u00e9rique en Python. Matplotlib Cheat Sheet : Des cheatsheets officielles de Matplotlib pour vous aider \u00e0 cr\u00e9er des graphiques en Python. Ces aides-m\u00e9moire couvrent une gamme de sujets en Python, de l'apprentissage des bases aux sujets plus avanc\u00e9s. Vous pouvez les utiliser comme r\u00e9f\u00e9rences rapides pendant votre apprentissage et votre d\u00e9veloppement en Python.","title":"Cheatsheets"},{"location":"aide/tools/#bibliotheques-et-outils","text":"","title":"Biblioth\u00e8ques et outils"},{"location":"aide/tools/#numpy","text":"NumPy est une biblioth\u00e8que puissante pour la manipulation de tableaux multidimensionnels et de donn\u00e9es num\u00e9riques. Il est largement utilis\u00e9 dans le domaine de la science des donn\u00e9es et de l'analyse num\u00e9rique.","title":"NumPy"},{"location":"aide/tools/#matplotlib","text":"Matplotlib est une biblioth\u00e8que pour la cr\u00e9ation de graphiques et de visualisations de donn\u00e9es en 2D et 3D. Elle est tr\u00e8s utile pour la repr\u00e9sentation graphique des donn\u00e9es.","title":"Matplotlib"},{"location":"aide/tools/#visual-studio-code-vs-code","text":"Visual Studio Code est un \u00e9diteur de code open-source d\u00e9velopp\u00e9 par Microsoft. Il prend en charge le d\u00e9veloppement Python avec des extensions utiles, telles que Python et Jupyter.","title":"Visual Studio Code (VS Code)"},{"location":"aide/tools/#pip","text":"pip est le gestionnaire de paquets Python par d\u00e9faut. Il vous permet d'installer et de g\u00e9rer des biblioth\u00e8ques tierces.","title":"pip"},{"location":"aide/tools/#replit","text":"Repl.it est une plateforme en ligne qui vous permet d'\u00e9crire, d'ex\u00e9cuter et de partager du code Python dans votre navigateur sans avoir \u00e0 installer quoi que ce soit sur votre ordinateur. Ces outils utilitaires en Python sont l\u00e0 pour vous aider dans votre apprentissage et votre d\u00e9veloppement en Python. N'h\u00e9sitez pas \u00e0 les explorer et \u00e0 les utiliser pour r\u00e9soudre des probl\u00e8mes, automatiser des t\u00e2ches et r\u00e9aliser des projets passionnants.","title":"Repl.it"},{"location":"epreuves/ds/","text":"DS info DS info avec corrig\u00e9. DS info Semestre 1 DS 1 info 2023-24: Enonc\u00e9.pdf | Corrig\u00e9.pdf | EX1-Corrig\u00e9.py | EX2-Corrig\u00e9.py DS 1 info 2022-23: Enonc\u00e9.pdf | Corrig\u00e9.pdf DS 1 info 2021-22: Enonc\u00e9.pdf | Corrig\u00e9.pdf","title":"DS info"},{"location":"epreuves/ds/#ds-info","text":"DS info avec corrig\u00e9.","title":"DS info"},{"location":"epreuves/ds/#ds-info-semestre-1","text":"DS 1 info 2023-24: Enonc\u00e9.pdf | Corrig\u00e9.pdf | EX1-Corrig\u00e9.py | EX2-Corrig\u00e9.py DS 1 info 2022-23: Enonc\u00e9.pdf | Corrig\u00e9.pdf DS 1 info 2021-22: Enonc\u00e9.pdf | Corrig\u00e9.pdf","title":"DS info Semestre 1"},{"location":"epreuves/examens/","text":"Examens info Examen info avec corrig\u00e9. Examens info Semestre 1 Examen 1 info 2023-24: Enonc\u00e9.pdf | Corrig\u00e9.pdf Concours blanc info Concours blanc info 2023-24: Enonc\u00e9.pdf | Corrig\u00e9.pdf","title":"Examens info"},{"location":"epreuves/examens/#examens-info","text":"Examen info avec corrig\u00e9.","title":"Examens info"},{"location":"epreuves/examens/#examens-info-semestre-1","text":"Examen 1 info 2023-24: Enonc\u00e9.pdf | Corrig\u00e9.pdf","title":"Examens info Semestre 1"},{"location":"epreuves/examens/#concours-blanc-info","text":"Concours blanc info 2023-24: Enonc\u00e9.pdf | Corrig\u00e9.pdf","title":"Concours blanc info"},{"location":"epreuves/tests/","text":"Tests info Tests info avec corrig\u00e9. Test info Semestre 1 2023-24 Test N\u00b01: Enonc\u00e9.pdf | Corrig\u00e9.pdf","title":"Tests info"},{"location":"epreuves/tests/#tests-info","text":"Tests info avec corrig\u00e9.","title":"Tests info"},{"location":"epreuves/tests/#test-info-semestre-1","text":"","title":"Test info Semestre 1"},{"location":"epreuves/tests/#2023-24","text":"Test N\u00b01: Enonc\u00e9.pdf | Corrig\u00e9.pdf","title":"2023-24"},{"location":"piles-files/cours-piles-files/","text":"Structures de Donn\u00e9es Avanc\u00e9es Les structures de donn\u00e9es sont un \u00e9l\u00e9ment essentiel de la programmation, utilis\u00e9es pour organiser et g\u00e9rer des donn\u00e9es de mani\u00e8re efficace. Deux structures de donn\u00e9es couramment utilis\u00e9es pour r\u00e9soudre divers probl\u00e8mes sont les piles ( stacks ) et les files ( queues ). Les Piles (Stacks) Une pile est une structure de donn\u00e9es lin\u00e9aire bas\u00e9e sur le principe Last In, First Out (LIFO) . Cela signifie que le dernier \u00e9l\u00e9ment ajout\u00e9 \u00e0 la pile est le premier \u00e0 \u00eatre retir\u00e9. Imaginez une pile d'assiettes : vous ajoutez toujours une nouvelle assiette au-dessus et vous la retirez \u00e9galement du dessus. Les op\u00e9rations fondamentales d'une pile sont : Push / Empiler : Pour ajouter un \u00e9l\u00e9ment au sommet de la pile. Pop / Depiler : Pour retirer l'\u00e9l\u00e9ment du sommet de la pile. Peek / Sommet : Pour consulter l'\u00e9l\u00e9ment en haut de la pile sans le retirer. isEmpty / Est_vide : Pour v\u00e9rifier si la pile est vide. size / Taille : Pour conna\u00eetre le nombre d'\u00e9l\u00e9ments dans la pile. This graph is created by @anis-saied with \u2665 using : DOT and Python pydot Les piles sont utilis\u00e9es dans diverses applications telles que l'\u00e9valuation d'expressions math\u00e9matiques, la gestion de la navigation dans un logiciel, la r\u00e9versibilit\u00e9 d'actions, etc. Les Files (Queues) Une file est \u00e9galement une structure de donn\u00e9es lin\u00e9aire, mais elle suit le principe First In, First Out (FIFO) . Cela signifie que le premier \u00e9l\u00e9ment ajout\u00e9 \u00e0 la file est le premier \u00e0 \u00eatre retir\u00e9. Imaginez une file d'attente dans un magasin : la premi\u00e8re personne arriv\u00e9e est la premi\u00e8re \u00e0 \u00eatre servie. Les op\u00e9rations fondamentales d'une file sont : Enqueue : Pour ajouter un \u00e9l\u00e9ment \u00e0 la fin de la file. Dequeue : Pour retirer l'\u00e9l\u00e9ment du d\u00e9but de la file. Front : Pour consulter l'\u00e9l\u00e9ment au d\u00e9but de la file sans le retirer. isEmpty : Pour v\u00e9rifier si la file est vide. size : Pour conna\u00eetre le nombre d'\u00e9l\u00e9ments dans la file. Les files sont utilis\u00e9es dans des situations o\u00f9 l'ordre d'arriv\u00e9e ou de traitement des \u00e9l\u00e9ments est important, comme la gestion des t\u00e2ches dans un syst\u00e8me de files d'attente, la collecte de donn\u00e9es dans un buffer, etc. Impl\u00e9mentation en Python Python offre la flexibilit\u00e9 d'impl\u00e9menter des piles et des files \u00e0 l'aide de listes (ou de la biblioth\u00e8que collections.deque pour des files plus efficaces).","title":"Structures de Donn\u00e9es Avanc\u00e9es"},{"location":"piles-files/cours-piles-files/#structures-de-donnees-avancees","text":"Les structures de donn\u00e9es sont un \u00e9l\u00e9ment essentiel de la programmation, utilis\u00e9es pour organiser et g\u00e9rer des donn\u00e9es de mani\u00e8re efficace. Deux structures de donn\u00e9es couramment utilis\u00e9es pour r\u00e9soudre divers probl\u00e8mes sont les piles ( stacks ) et les files ( queues ).","title":"Structures de Donn\u00e9es Avanc\u00e9es"},{"location":"piles-files/cours-piles-files/#les-piles-stacks","text":"Une pile est une structure de donn\u00e9es lin\u00e9aire bas\u00e9e sur le principe Last In, First Out (LIFO) . Cela signifie que le dernier \u00e9l\u00e9ment ajout\u00e9 \u00e0 la pile est le premier \u00e0 \u00eatre retir\u00e9. Imaginez une pile d'assiettes : vous ajoutez toujours une nouvelle assiette au-dessus et vous la retirez \u00e9galement du dessus. Les op\u00e9rations fondamentales d'une pile sont : Push / Empiler : Pour ajouter un \u00e9l\u00e9ment au sommet de la pile. Pop / Depiler : Pour retirer l'\u00e9l\u00e9ment du sommet de la pile. Peek / Sommet : Pour consulter l'\u00e9l\u00e9ment en haut de la pile sans le retirer. isEmpty / Est_vide : Pour v\u00e9rifier si la pile est vide. size / Taille : Pour conna\u00eetre le nombre d'\u00e9l\u00e9ments dans la pile. This graph is created by @anis-saied with \u2665 using : DOT and Python pydot Les piles sont utilis\u00e9es dans diverses applications telles que l'\u00e9valuation d'expressions math\u00e9matiques, la gestion de la navigation dans un logiciel, la r\u00e9versibilit\u00e9 d'actions, etc.","title":"Les Piles (Stacks)"},{"location":"piles-files/cours-piles-files/#les-files-queues","text":"Une file est \u00e9galement une structure de donn\u00e9es lin\u00e9aire, mais elle suit le principe First In, First Out (FIFO) . Cela signifie que le premier \u00e9l\u00e9ment ajout\u00e9 \u00e0 la file est le premier \u00e0 \u00eatre retir\u00e9. Imaginez une file d'attente dans un magasin : la premi\u00e8re personne arriv\u00e9e est la premi\u00e8re \u00e0 \u00eatre servie. Les op\u00e9rations fondamentales d'une file sont : Enqueue : Pour ajouter un \u00e9l\u00e9ment \u00e0 la fin de la file. Dequeue : Pour retirer l'\u00e9l\u00e9ment du d\u00e9but de la file. Front : Pour consulter l'\u00e9l\u00e9ment au d\u00e9but de la file sans le retirer. isEmpty : Pour v\u00e9rifier si la file est vide. size : Pour conna\u00eetre le nombre d'\u00e9l\u00e9ments dans la file. Les files sont utilis\u00e9es dans des situations o\u00f9 l'ordre d'arriv\u00e9e ou de traitement des \u00e9l\u00e9ments est important, comme la gestion des t\u00e2ches dans un syst\u00e8me de files d'attente, la collecte de donn\u00e9es dans un buffer, etc.","title":"Les Files (Queues)"},{"location":"piles-files/cours-piles-files/#implementation-en-python","text":"Python offre la flexibilit\u00e9 d'impl\u00e9menter des piles et des files \u00e0 l'aide de listes (ou de la biblioth\u00e8que collections.deque pour des files plus efficaces).","title":"Impl\u00e9mentation en Python"},{"location":"piles-files/file/","text":"Travaux Pratiques : Structures de Donn\u00e9es - Files en Python Objectif L'objectif de ce TP est de vous familiariser avec les structures de donn\u00e9es de files en Python et de comprendre comment elles fonctionnent. Les files sont des structures de donn\u00e9es fondamentales utilis\u00e9es pour r\u00e9soudre une vari\u00e9t\u00e9 de probl\u00e8mes informatiques, notamment la gestion de l'ordonnancement des t\u00e2ches, l'acc\u00e8s \u00e0 des ressources partag\u00e9es de mani\u00e8re \u00e9quitable, et bien plus encore. Ce TP est con\u00e7u pour vous aider \u00e0 : Comprendre les concepts de base des files , y compris le principe First In, First Out (FIFO) . Impl\u00e9menter une file en Python \u00e0 l'aide de listes . Effectuer des op\u00e9rations courantes sur une file, telles que enqueue (enfiler), dequeue (defiler), peek (sommet), isEmpty , et size . R\u00e9soudre des probl\u00e8mes pratiques en utilisant des files, tels que la simulation de file d'attente. \u00c0 la fin, vous serez pr\u00eat \u00e0 appliquer vos connaissances sur les files \u00e0 des probl\u00e8mes r\u00e9els et \u00e0 poursuivre votre exploration des structures de donn\u00e9es en informatique. Enonc\u00e9 et corrig\u00e9s Enonc\u00e9 : disponible au format PDF Corrig\u00e9 : disponible au format PDF et Python (.py) TP3_SP1.py | TP3_SP1.pdf TP3_SM1.py | TP3_SM1.pdf TP3_ST3.py | TP3_ST3.pdf TP3_ST1.py | TP3_ST1.pdf TP3_SM4.py | TP3_SM4.pdf TP3_SP3.py | TP3_SP3.pdf TP3_SP2.py | TP3_SP2.pdf","title":"TP3 Les Files"},{"location":"piles-files/file/#travaux-pratiques-structures-de-donnees-files-en-python","text":"","title":"Travaux Pratiques : Structures de Donn\u00e9es - Files en Python"},{"location":"piles-files/file/#objectif","text":"L'objectif de ce TP est de vous familiariser avec les structures de donn\u00e9es de files en Python et de comprendre comment elles fonctionnent. Les files sont des structures de donn\u00e9es fondamentales utilis\u00e9es pour r\u00e9soudre une vari\u00e9t\u00e9 de probl\u00e8mes informatiques, notamment la gestion de l'ordonnancement des t\u00e2ches, l'acc\u00e8s \u00e0 des ressources partag\u00e9es de mani\u00e8re \u00e9quitable, et bien plus encore. Ce TP est con\u00e7u pour vous aider \u00e0 : Comprendre les concepts de base des files , y compris le principe First In, First Out (FIFO) . Impl\u00e9menter une file en Python \u00e0 l'aide de listes . Effectuer des op\u00e9rations courantes sur une file, telles que enqueue (enfiler), dequeue (defiler), peek (sommet), isEmpty , et size . R\u00e9soudre des probl\u00e8mes pratiques en utilisant des files, tels que la simulation de file d'attente. \u00c0 la fin, vous serez pr\u00eat \u00e0 appliquer vos connaissances sur les files \u00e0 des probl\u00e8mes r\u00e9els et \u00e0 poursuivre votre exploration des structures de donn\u00e9es en informatique.","title":"Objectif"},{"location":"piles-files/file/#enonce-et-corriges","text":"Enonc\u00e9 : disponible au format PDF Corrig\u00e9 : disponible au format PDF et Python (.py) TP3_SP1.py | TP3_SP1.pdf TP3_SM1.py | TP3_SM1.pdf TP3_ST3.py | TP3_ST3.pdf TP3_ST1.py | TP3_ST1.pdf TP3_SM4.py | TP3_SM4.pdf TP3_SP3.py | TP3_SP3.pdf TP3_SP2.py | TP3_SP2.pdf","title":"Enonc\u00e9 et corrig\u00e9s"},{"location":"piles-files/introduction/","text":"Structures de donn\u00e9es en python Introduction aux Types de Donn\u00e9es en Python Les types de donn\u00e9es jouent un r\u00f4le essentiel dans la programmation en Python, d\u00e9terminant comment les informations sont stock\u00e9es, manipul\u00e9es et interpr\u00e9t\u00e9es par un programme. Ce graphe explore les diff\u00e9rents types de donn\u00e9es disponibles en Python, class\u00e9s en deux grandes cat\u00e9gories : les types pr\u00e9d\u00e9finis int\u00e9gr\u00e9s au language et les types utilisateur que vous pouvez cr\u00e9er. Chaque cat\u00e9gorie comprend une vari\u00e9t\u00e9 de types, notamment des types modifiables et non modifiables, des types simples et des conteneurs. Comprendre ces types est fondamental pour devenir un d\u00e9veloppeur Python comp\u00e9tent. This graph is created by @anis-saied with \u2665 using : DOT and Python pydot Description du Graphe des Types de Donn\u00e9es Le graphe ci-dessus pr\u00e9sente une classification visuelle des types de donn\u00e9es en Python. Il est con\u00e7u pour vous aider \u00e0 comprendre la structure des types de donn\u00e9es disponibles dans le langage. Voici une br\u00e8ve description de chaque composant du graphe : Types pr\u00e9d\u00e9finis : Cette section regroupe les types de donn\u00e9es int\u00e9gr\u00e9s \u00e0 Python, y compris les types modifiables et non modifiables. Types modifiables : Ce sous-groupe comprend des conteneurs tels que les listes ( list ), les ensembles ( set ), et les dictionnaires ( dict ). Ces types peuvent \u00eatre modifi\u00e9s apr\u00e8s leur cr\u00e9ation. Types non modifiables : Cette sous-section comprend les types de donn\u00e9es simples tels que les entiers ( int ) et les nombres \u00e0 virgule flottante ( float ), ainsi que des conteneurs immuables tels que les cha\u00eenes ( str ) et les tuples ( tuple ). Types utilisateur : Cette section repr\u00e9sente les types de donn\u00e9es que vous pouvez cr\u00e9er vous-m\u00eame. Elle inclut des exemples tels que les piles ( pile ), les files ( file ), les tableaux ( array ), et d'autres types personnalis\u00e9s que vous pouvez d\u00e9finir en fonction de vos besoins. En explorant ce graphe, vous aurez une meilleure compr\u00e9hension de la richesse des types de donn\u00e9es disponibles en Python, ce qui vous aidera \u00e0 choisir les structures de donn\u00e9es appropri\u00e9es pour vos exercices et \u00e0 manipuler les donn\u00e9es de mani\u00e8re efficace.","title":"Introduction"},{"location":"piles-files/introduction/#structures-de-donnees-en-python","text":"Introduction aux Types de Donn\u00e9es en Python Les types de donn\u00e9es jouent un r\u00f4le essentiel dans la programmation en Python, d\u00e9terminant comment les informations sont stock\u00e9es, manipul\u00e9es et interpr\u00e9t\u00e9es par un programme. Ce graphe explore les diff\u00e9rents types de donn\u00e9es disponibles en Python, class\u00e9s en deux grandes cat\u00e9gories : les types pr\u00e9d\u00e9finis int\u00e9gr\u00e9s au language et les types utilisateur que vous pouvez cr\u00e9er. Chaque cat\u00e9gorie comprend une vari\u00e9t\u00e9 de types, notamment des types modifiables et non modifiables, des types simples et des conteneurs. Comprendre ces types est fondamental pour devenir un d\u00e9veloppeur Python comp\u00e9tent. This graph is created by @anis-saied with \u2665 using : DOT and Python pydot Description du Graphe des Types de Donn\u00e9es Le graphe ci-dessus pr\u00e9sente une classification visuelle des types de donn\u00e9es en Python. Il est con\u00e7u pour vous aider \u00e0 comprendre la structure des types de donn\u00e9es disponibles dans le langage. Voici une br\u00e8ve description de chaque composant du graphe : Types pr\u00e9d\u00e9finis : Cette section regroupe les types de donn\u00e9es int\u00e9gr\u00e9s \u00e0 Python, y compris les types modifiables et non modifiables. Types modifiables : Ce sous-groupe comprend des conteneurs tels que les listes ( list ), les ensembles ( set ), et les dictionnaires ( dict ). Ces types peuvent \u00eatre modifi\u00e9s apr\u00e8s leur cr\u00e9ation. Types non modifiables : Cette sous-section comprend les types de donn\u00e9es simples tels que les entiers ( int ) et les nombres \u00e0 virgule flottante ( float ), ainsi que des conteneurs immuables tels que les cha\u00eenes ( str ) et les tuples ( tuple ). Types utilisateur : Cette section repr\u00e9sente les types de donn\u00e9es que vous pouvez cr\u00e9er vous-m\u00eame. Elle inclut des exemples tels que les piles ( pile ), les files ( file ), les tableaux ( array ), et d'autres types personnalis\u00e9s que vous pouvez d\u00e9finir en fonction de vos besoins. En explorant ce graphe, vous aurez une meilleure compr\u00e9hension de la richesse des types de donn\u00e9es disponibles en Python, ce qui vous aidera \u00e0 choisir les structures de donn\u00e9es appropri\u00e9es pour vos exercices et \u00e0 manipuler les donn\u00e9es de mani\u00e8re efficace.","title":"Structures de donn\u00e9es en python"},{"location":"piles-files/pile/","text":"Travaux Pratiques : Structures de Donn\u00e9es - Piles en Python Objectif L'objectif de ce TP est de vous familiariser avec les structures de donn\u00e9es de piles en Python et de comprendre comment elles fonctionnent. Les piles sont des structures de donn\u00e9es fondamentales utilis\u00e9es pour r\u00e9soudre une vari\u00e9t\u00e9 de probl\u00e8mes informatiques, notamment la gestion de la m\u00e9moire, l'\u00e9valuation d'expressions math\u00e9matiques, la navigation dans un logiciel, et bien plus encore. Ce TP est con\u00e7u pour vous aider \u00e0 : Comprendre les concepts de base des piles, y compris le principe Last In, First Out (LIFO). Impl\u00e9menter une pile en Python \u00e0 l'aide de listes. Effectuer des op\u00e9rations courantes sur une pile, telles que push, pop, peek, isEmpty, et size. R\u00e9soudre des probl\u00e8mes pratiques en utilisant des piles, tels que l'\u00e9quilibrage des parenth\u00e8ses dans une expression math\u00e9matique. \u00c0 la fin, vous serez pr\u00eat \u00e0 appliquer vos connaissances sur les piles \u00e0 des probl\u00e8mes r\u00e9els et \u00e0 poursuivre votre exploration des structures de donn\u00e9es en informatique. Enonc\u00e9 et corrig\u00e9s Enonc\u00e9 : disponible au format PDF Corrig\u00e9 : disponible au format PDF et Python (.py) TP2_SP1.py | TP2_SP1.pdf TP2_SM1.py | TP2_SM1.pdf TP2_SM4.py | TP2_SM4.pdf TP2_ST3.py | TP2_ST3.pdf TP2_SP3.py | TP2_SP3.pdf TP2_SP2.py | TP2_SP2.pdf Remarques Importantes Gestion des erreurs de pile vide : Assurez-vous de manipuler les piles avec pr\u00e9caution pour \u00e9viter les erreurs li\u00e9es aux piles vides. Utilisez des v\u00e9rifications appropri\u00e9es avant d'effectuer des op\u00e9rations de d\u00e9pilement, telles que if not pile_vide(p): avant d'appeler depiler(p) . Documentez votre code : Lorsque vous utilisez des piles dans vos programmes, assurez-vous de les documenter ad\u00e9quatement pour expliquer leur utilisation et les invariants qu'elles maintiennent.","title":"TP2 Les Piles"},{"location":"piles-files/pile/#travaux-pratiques-structures-de-donnees-piles-en-python","text":"","title":"Travaux Pratiques : Structures de Donn\u00e9es - Piles en Python"},{"location":"piles-files/pile/#objectif","text":"L'objectif de ce TP est de vous familiariser avec les structures de donn\u00e9es de piles en Python et de comprendre comment elles fonctionnent. Les piles sont des structures de donn\u00e9es fondamentales utilis\u00e9es pour r\u00e9soudre une vari\u00e9t\u00e9 de probl\u00e8mes informatiques, notamment la gestion de la m\u00e9moire, l'\u00e9valuation d'expressions math\u00e9matiques, la navigation dans un logiciel, et bien plus encore. Ce TP est con\u00e7u pour vous aider \u00e0 : Comprendre les concepts de base des piles, y compris le principe Last In, First Out (LIFO). Impl\u00e9menter une pile en Python \u00e0 l'aide de listes. Effectuer des op\u00e9rations courantes sur une pile, telles que push, pop, peek, isEmpty, et size. R\u00e9soudre des probl\u00e8mes pratiques en utilisant des piles, tels que l'\u00e9quilibrage des parenth\u00e8ses dans une expression math\u00e9matique. \u00c0 la fin, vous serez pr\u00eat \u00e0 appliquer vos connaissances sur les piles \u00e0 des probl\u00e8mes r\u00e9els et \u00e0 poursuivre votre exploration des structures de donn\u00e9es en informatique.","title":"Objectif"},{"location":"piles-files/pile/#enonce-et-corriges","text":"Enonc\u00e9 : disponible au format PDF Corrig\u00e9 : disponible au format PDF et Python (.py) TP2_SP1.py | TP2_SP1.pdf TP2_SM1.py | TP2_SM1.pdf TP2_SM4.py | TP2_SM4.pdf TP2_ST3.py | TP2_ST3.pdf TP2_SP3.py | TP2_SP3.pdf TP2_SP2.py | TP2_SP2.pdf","title":"Enonc\u00e9 et corrig\u00e9s"},{"location":"piles-files/pile/#remarques-importantes","text":"Gestion des erreurs de pile vide : Assurez-vous de manipuler les piles avec pr\u00e9caution pour \u00e9viter les erreurs li\u00e9es aux piles vides. Utilisez des v\u00e9rifications appropri\u00e9es avant d'effectuer des op\u00e9rations de d\u00e9pilement, telles que if not pile_vide(p): avant d'appeler depiler(p) . Documentez votre code : Lorsque vous utilisez des piles dans vos programmes, assurez-vous de les documenter ad\u00e9quatement pour expliquer leur utilisation et les invariants qu'elles maintiennent.","title":"Remarques Importantes"},{"location":"poo/introduction/","text":"Introduction \u00e0 la Programmation Orient\u00e9e Objet (POO) en Python La Programmation Orient\u00e9e Objet (POO) est l'un des concepts fondamentaux de la programmation informatique. Elle constitue un paradigme de programmation puissant qui permet de structurer et d'organiser le code de mani\u00e8re plus modulaire et plus compr\u00e9hensible. Dans ce chapitre, nous explorerons la POO en utilisant le langage de programmation Python. C'est quoi est la POO ? La Programmation Orient\u00e9e Objet est un paradigme de programmation qui repose sur le concept d' objets . Un objet est une instance d'une classe , qui est un mod\u00e8le ou un plan pour cr\u00e9er des objets. Les objets peuvent contenir des donn\u00e9es (appel\u00e9es attributs ) et des fonctions (appel\u00e9es m\u00e9thodes ) qui agissent sur ces donn\u00e9es. Pourquoi utiliser la POO ? La POO offre de nombreux avantages, notamment : Modularit\u00e9 : Vous pouvez organiser votre code en objets ind\u00e9pendants, ce qui le rend plus facile \u00e0 comprendre et \u00e0 maintenir. R\u00e9utilisation du code : Vous pouvez r\u00e9utiliser des classes existantes pour cr\u00e9er de nouveaux objets, ce qui \u00e9conomise du temps et de l'effort. Encapsulation : Vous pouvez encapsuler les donn\u00e9es et les fonctions li\u00e9es dans une classe, ce qui permet de contr\u00f4ler l'acc\u00e8s aux donn\u00e9es et de garantir la coh\u00e9rence. H\u00e9ritage : Vous pouvez cr\u00e9er de nouvelles classes en h\u00e9ritant des fonctionnalit\u00e9s d'autres classes, favorisant la r\u00e9utilisation et l'extension du code. Comment utiliser la POO ? En Python, vous pouvez cr\u00e9er des classes en utilisant le mot-cl\u00e9 class , d\u00e9finir des attributs dans le constructeur __init__ , et cr\u00e9er des m\u00e9thodes pour effectuer des op\u00e9rations sur les objets. Voici une syntaxe de base : class MaClasse: def __init__(self, parametre): self.attribut = parametre def ma_methode(self): # Faire quelque chose avec self.attribut Quand utiliser la POO ? La POO est particuli\u00e8rement utile lorsque vous travaillez sur des projets de grande envergure ou lorsque vous devez mod\u00e9liser des entit\u00e9s du monde r\u00e9el dans votre programme. Cependant, elle peut \u00eatre appliqu\u00e9e dans des projets de toutes tailles pour am\u00e9liorer la structure et la lisibilit\u00e9 du code. \u00c0 quoi sert la POO ? La POO permet de r\u00e9soudre des probl\u00e8mes complexes en les d\u00e9composant en objets interagissant entre eux. Par exemple, vous pouvez utiliser la POO pour mod\u00e9liser une biblioth\u00e8que, une simulation de jeu, ou m\u00eame des composants logiciels. Alternative \u00e0 la POO Bien que la POO soit puissante, il existe d'autres paradigmes de programmation comme la programmation proc\u00e9durale et la programmation fonctionnelle. Le choix du paradigme d\u00e9pend du contexte et des exigences du projet. Objectif de ce chapitre L'objectif de ce chapitre est de vous initier \u00e0 la POO en Python. Nous explorerons la syntaxe de base, l'h\u00e9ritage, et les m\u00e9thodes sp\u00e9ciales. Vous apprendrez \u00e0 concevoir des classes, \u00e0 cr\u00e9er des objets, \u00e0 utiliser l'h\u00e9ritage pour r\u00e9utiliser du code, et \u00e0 personnaliser le comportement de vos classes en utilisant des m\u00e9thodes sp\u00e9ciales. Contenu du Cours Le cours sur la POO en Python sera divis\u00e9 en trois s\u00e9ances, chacune approfondissant un aspect crucial de la programmation orient\u00e9e objet. Voici un aper\u00e7u du contenu du cours : S\u00e9ance 1 : Syntaxe de Base de la POO en Python Introduction aux classes et aux objets. Cr\u00e9ation de classes et d'objets. Attributs et m\u00e9thodes. Constructeurs et destructeurs. S\u00e9ance 2 : H\u00e9ritage et Polymorphisme H\u00e9ritage de classes. Surcharge de m\u00e9thodes. Polymorphisme. S\u00e9ance 3 : M\u00e9thodes Sp\u00e9ciales et Utilisation Avanc\u00e9e M\u00e9thodes sp\u00e9ciales en Python (e.g., str , eq , add ). Encapsulation. Utilisation avanc\u00e9e de la POO.","title":"Introduction"},{"location":"poo/introduction/#introduction-a-la-programmation-orientee-objet-poo-en-python","text":"La Programmation Orient\u00e9e Objet (POO) est l'un des concepts fondamentaux de la programmation informatique. Elle constitue un paradigme de programmation puissant qui permet de structurer et d'organiser le code de mani\u00e8re plus modulaire et plus compr\u00e9hensible. Dans ce chapitre, nous explorerons la POO en utilisant le langage de programmation Python.","title":"Introduction \u00e0 la Programmation Orient\u00e9e Objet (POO) en Python"},{"location":"poo/introduction/#cest-quoi-est-la-poo","text":"La Programmation Orient\u00e9e Objet est un paradigme de programmation qui repose sur le concept d' objets . Un objet est une instance d'une classe , qui est un mod\u00e8le ou un plan pour cr\u00e9er des objets. Les objets peuvent contenir des donn\u00e9es (appel\u00e9es attributs ) et des fonctions (appel\u00e9es m\u00e9thodes ) qui agissent sur ces donn\u00e9es.","title":"C'est quoi est la POO ?"},{"location":"poo/introduction/#pourquoi-utiliser-la-poo","text":"La POO offre de nombreux avantages, notamment : Modularit\u00e9 : Vous pouvez organiser votre code en objets ind\u00e9pendants, ce qui le rend plus facile \u00e0 comprendre et \u00e0 maintenir. R\u00e9utilisation du code : Vous pouvez r\u00e9utiliser des classes existantes pour cr\u00e9er de nouveaux objets, ce qui \u00e9conomise du temps et de l'effort. Encapsulation : Vous pouvez encapsuler les donn\u00e9es et les fonctions li\u00e9es dans une classe, ce qui permet de contr\u00f4ler l'acc\u00e8s aux donn\u00e9es et de garantir la coh\u00e9rence. H\u00e9ritage : Vous pouvez cr\u00e9er de nouvelles classes en h\u00e9ritant des fonctionnalit\u00e9s d'autres classes, favorisant la r\u00e9utilisation et l'extension du code.","title":"Pourquoi utiliser la POO ?"},{"location":"poo/introduction/#comment-utiliser-la-poo","text":"En Python, vous pouvez cr\u00e9er des classes en utilisant le mot-cl\u00e9 class , d\u00e9finir des attributs dans le constructeur __init__ , et cr\u00e9er des m\u00e9thodes pour effectuer des op\u00e9rations sur les objets. Voici une syntaxe de base : class MaClasse: def __init__(self, parametre): self.attribut = parametre def ma_methode(self): # Faire quelque chose avec self.attribut","title":"Comment utiliser la POO ?"},{"location":"poo/introduction/#quand-utiliser-la-poo","text":"La POO est particuli\u00e8rement utile lorsque vous travaillez sur des projets de grande envergure ou lorsque vous devez mod\u00e9liser des entit\u00e9s du monde r\u00e9el dans votre programme. Cependant, elle peut \u00eatre appliqu\u00e9e dans des projets de toutes tailles pour am\u00e9liorer la structure et la lisibilit\u00e9 du code.","title":"Quand utiliser la POO ?"},{"location":"poo/introduction/#a-quoi-sert-la-poo","text":"La POO permet de r\u00e9soudre des probl\u00e8mes complexes en les d\u00e9composant en objets interagissant entre eux. Par exemple, vous pouvez utiliser la POO pour mod\u00e9liser une biblioth\u00e8que, une simulation de jeu, ou m\u00eame des composants logiciels.","title":"\u00c0 quoi sert la POO ?"},{"location":"poo/introduction/#alternative-a-la-poo","text":"Bien que la POO soit puissante, il existe d'autres paradigmes de programmation comme la programmation proc\u00e9durale et la programmation fonctionnelle. Le choix du paradigme d\u00e9pend du contexte et des exigences du projet.","title":"Alternative \u00e0 la POO"},{"location":"poo/introduction/#objectif-de-ce-chapitre","text":"L'objectif de ce chapitre est de vous initier \u00e0 la POO en Python. Nous explorerons la syntaxe de base, l'h\u00e9ritage, et les m\u00e9thodes sp\u00e9ciales. Vous apprendrez \u00e0 concevoir des classes, \u00e0 cr\u00e9er des objets, \u00e0 utiliser l'h\u00e9ritage pour r\u00e9utiliser du code, et \u00e0 personnaliser le comportement de vos classes en utilisant des m\u00e9thodes sp\u00e9ciales.","title":"Objectif de ce chapitre"},{"location":"poo/introduction/#contenu-du-cours","text":"Le cours sur la POO en Python sera divis\u00e9 en trois s\u00e9ances, chacune approfondissant un aspect crucial de la programmation orient\u00e9e objet. Voici un aper\u00e7u du contenu du cours :","title":"Contenu du Cours"},{"location":"poo/introduction/#seance-1-syntaxe-de-base-de-la-poo-en-python","text":"Introduction aux classes et aux objets. Cr\u00e9ation de classes et d'objets. Attributs et m\u00e9thodes. Constructeurs et destructeurs.","title":"S\u00e9ance 1 : Syntaxe de Base de la POO en Python"},{"location":"poo/introduction/#seance-2-heritage-et-polymorphisme","text":"H\u00e9ritage de classes. Surcharge de m\u00e9thodes. Polymorphisme.","title":"S\u00e9ance 2 : H\u00e9ritage et Polymorphisme"},{"location":"poo/introduction/#seance-3-methodes-speciales-et-utilisation-avancee","text":"M\u00e9thodes sp\u00e9ciales en Python (e.g., str , eq , add ). Encapsulation. Utilisation avanc\u00e9e de la POO.","title":"S\u00e9ance 3 : M\u00e9thodes Sp\u00e9ciales et Utilisation Avanc\u00e9e"},{"location":"poo/plan/","text":"Introduction \u00e0 la Programmation Orient\u00e9e Objet (POO) en Python Objectif de ce chapitre L'objectif de ce chapitre est de vous initier \u00e0 la POO en Python. Nous explorerons la syntaxe de base, l'h\u00e9ritage, et les m\u00e9thodes sp\u00e9ciales. Vous apprendrez \u00e0 concevoir des classes, \u00e0 cr\u00e9er des objets, \u00e0 utiliser l'h\u00e9ritage pour r\u00e9utiliser du code, et \u00e0 personnaliser le comportement de vos classes en utilisant des m\u00e9thodes sp\u00e9ciales. Contenu du Cours Le cours sur la POO en Python sera divis\u00e9 en trois s\u00e9ances, chacune approfondissant un aspect crucial de la programmation orient\u00e9e objet. Voici un aper\u00e7u du contenu du cours : S\u00e9ance 1 : Syntaxe de Base de la POO en Python Introduction aux classes et aux objets . Cr\u00e9ation de classes et d'objets . Attributs M\u00e9thodes . Constructeurs et destructeurs . T\u00e9l\u00e9charger cours partie 1 (pdf): Syntaxe de Base de la POO en Python.pdf Corrig\u00e9 des exercices du cours: Ex1 class rectangle.py - Ex1 class rectangle.pdf Ex2 class voiture.py - Ex2 class voiture.pdf Ex3 class point.py - Ex3 class point.pdf S\u00e9ance 2 : H\u00e9ritage, Polymorphisme et Surcharges des m\u00e9thodes H\u00e9ritage de classes . Polymorphisme et surcharge de m\u00e9thodes . T\u00e9l\u00e9charger cours partie 2 (pdf): H\u00e9ritage, Polymorphisme et Surcharges des m\u00e9thodes en Python.pdf S\u00e9ance 3 : M\u00e9thodes Sp\u00e9ciales et Utilisation Avanc\u00e9e La classe Object . Les M\u00e9thodes sp\u00e9ciales en Python (exemples : __str__ , __eq__ , __add__ ). Encapsulation . T\u00e9l\u00e9charger cours partie 3 (pdf): La classe Object et les M\u00e9thodes sp\u00e9ciales en Python.pdf TP POO TP 1 Programmation Orient\u00e9e Objet (POO) en Python","title":"Plan du cours"},{"location":"poo/plan/#introduction-a-la-programmation-orientee-objet-poo-en-python","text":"","title":"Introduction \u00e0 la Programmation Orient\u00e9e Objet (POO) en Python"},{"location":"poo/plan/#objectif-de-ce-chapitre","text":"L'objectif de ce chapitre est de vous initier \u00e0 la POO en Python. Nous explorerons la syntaxe de base, l'h\u00e9ritage, et les m\u00e9thodes sp\u00e9ciales. Vous apprendrez \u00e0 concevoir des classes, \u00e0 cr\u00e9er des objets, \u00e0 utiliser l'h\u00e9ritage pour r\u00e9utiliser du code, et \u00e0 personnaliser le comportement de vos classes en utilisant des m\u00e9thodes sp\u00e9ciales.","title":"Objectif de ce chapitre"},{"location":"poo/plan/#contenu-du-cours","text":"Le cours sur la POO en Python sera divis\u00e9 en trois s\u00e9ances, chacune approfondissant un aspect crucial de la programmation orient\u00e9e objet. Voici un aper\u00e7u du contenu du cours :","title":"Contenu du Cours"},{"location":"poo/plan/#seance-1-syntaxe-de-base-de-la-poo-en-python","text":"Introduction aux classes et aux objets . Cr\u00e9ation de classes et d'objets . Attributs M\u00e9thodes . Constructeurs et destructeurs . T\u00e9l\u00e9charger cours partie 1 (pdf): Syntaxe de Base de la POO en Python.pdf Corrig\u00e9 des exercices du cours: Ex1 class rectangle.py - Ex1 class rectangle.pdf Ex2 class voiture.py - Ex2 class voiture.pdf Ex3 class point.py - Ex3 class point.pdf","title":"S\u00e9ance 1 : Syntaxe de Base de la POO en Python"},{"location":"poo/plan/#seance-2-heritage-polymorphisme-et-surcharges-des-methodes","text":"H\u00e9ritage de classes . Polymorphisme et surcharge de m\u00e9thodes . T\u00e9l\u00e9charger cours partie 2 (pdf): H\u00e9ritage, Polymorphisme et Surcharges des m\u00e9thodes en Python.pdf","title":"S\u00e9ance 2 : H\u00e9ritage, Polymorphisme et Surcharges des m\u00e9thodes"},{"location":"poo/plan/#seance-3-methodes-speciales-et-utilisation-avancee","text":"La classe Object . Les M\u00e9thodes sp\u00e9ciales en Python (exemples : __str__ , __eq__ , __add__ ). Encapsulation . T\u00e9l\u00e9charger cours partie 3 (pdf): La classe Object et les M\u00e9thodes sp\u00e9ciales en Python.pdf","title":"S\u00e9ance 3 : M\u00e9thodes Sp\u00e9ciales et Utilisation Avanc\u00e9e"},{"location":"poo/plan/#tp-poo","text":"TP 1 Programmation Orient\u00e9e Objet (POO) en Python","title":"TP POO"},{"location":"poo/tp-poo/","text":"TP Programmation Orient\u00e9e Objet (POO) en Python T\u00e9l\u00e9charger : TP POO.pdf Corrig\u00e9s Corrig\u00e9 des exercices : Ex 1 : TP_POO_Ex1.py - TP_POO_Ex1.pdf Ex 5 : TP_POO_Ex5.py - TP_POO_Ex5.pdf Ex 6 : TP_POO_Ex6.py - TP_POO_Ex6.pdf Ex 7 : TP_POO_Ex8.py - TP_POO_Ex7.pdf Ex 8 : TP_POO_Ex8.py - TP_POO_Ex8.pdf EX 10 : TP_POO_Ex10.py - TP_POO_Ex10.pdf","title":"TP POO"},{"location":"poo/tp-poo/#tp-programmation-orientee-objet-poo-en-python","text":"T\u00e9l\u00e9charger : TP POO.pdf","title":"TP Programmation Orient\u00e9e Objet (POO) en Python"},{"location":"poo/tp-poo/#corriges","text":"Corrig\u00e9 des exercices : Ex 1 : TP_POO_Ex1.py - TP_POO_Ex1.pdf Ex 5 : TP_POO_Ex5.py - TP_POO_Ex5.pdf Ex 6 : TP_POO_Ex6.py - TP_POO_Ex6.pdf Ex 7 : TP_POO_Ex8.py - TP_POO_Ex7.pdf Ex 8 : TP_POO_Ex8.py - TP_POO_Ex8.pdf EX 10 : TP_POO_Ex10.py - TP_POO_Ex10.pdf","title":"Corrig\u00e9s"},{"location":"poo/seance-1/attributs/","text":"Les attributs Python prend en charge plusieurs types d'attributs, qui sont des variables associ\u00e9es \u00e0 des classes et \u00e0 des objets. Chacun de ces types d'attributs a des caract\u00e9ristiques distinctes et est utilis\u00e9 dans des contextes diff\u00e9rents. Les attributs peuvent \u00eatre class\u00e9s en trois cat\u00e9gories principales : les attributs de classe, les attributs d'instance et les attributs associ\u00e9s \u00e0 l'objet apr\u00e8s son instanciation. Attributs de Classe Les attributs de classe sont partag\u00e9s par toutes les instances (objets) de la classe. Ils sont d\u00e9finis \u00e0 l'int\u00e9rieur de la classe, en dehors des m\u00e9thodes, et ne sont pas li\u00e9s \u00e0 une instance sp\u00e9cifique. Les attributs de classe sont g\u00e9n\u00e9ralement utilis\u00e9s pour stocker des informations qui sont partag\u00e9es par toutes les instances de la classe. Exemple : class Compteur: count = 0 # Attribut de classe def __init__(self): Compteur.count += 1 # Incr\u00e9mente l'attribut de classe # lors de la cr\u00e9ation d'une instance # Utilisation des attributs de classe objet1 = Compteur() print(Compteur.count) # Affiche 1 objet2 = Compteur() print(Compteur.count) # Affiche 2 Quand utiliser les attributs de classe ? Utilisez des attributs de classe lorsque vous avez besoin de stocker des donn\u00e9es qui sont partag\u00e9es par toutes les instances de la classe, comme un compteur global. Attributs d'Instance Les attributs d'instance sont sp\u00e9cifiques \u00e0 chaque instance de la classe. Chaque objet a sa propre copie des attributs d'instance. Ils sont g\u00e9n\u00e9ralement d\u00e9finis dans le constructeur de la classe ( __init__ ) en utilisant le pr\u00e9fixe self . Les attributs d'instance sont utilis\u00e9s pour stocker des donn\u00e9es sp\u00e9cifiques \u00e0 chaque objet. Exemple : class Personne: def __init__(self, nom, age): self.nom = nom # Attribut d'instance self.age = age # Attribut d'instance # Utilisation des attributs d'instance personne1 = Personne(\"Alice\", 30) print(personne1.nom) # Affiche \"Alice\" print(personne1.age) # Affiche 30 personne2 = Personne(\"Bob\", 25) print(personne2.nom) # Affiche \"Bob\" print(personne2.age) # Affiche 25 Quand utiliser les attributs d'instance ? Utilisez des attributs d'instance lorsque vous devez stocker des donn\u00e9es sp\u00e9cifiques \u00e0 chaque objet, telles que les caract\u00e9ristiques individuelles d'une personne. Attributs Associ\u00e9s \u00e0 l'Objet apr\u00e8s son Instanciation En Python, vous pouvez ajouter des attributs \u00e0 un objet apr\u00e8s son instanciation. Ces attributs ne sont pas d\u00e9finis dans la classe ou le constructeur, mais ils sont attach\u00e9s \u00e0 l'objet \u00e0 la vol\u00e9e. Cette flexibilit\u00e9 est utile lorsque vous avez besoin d'ajouter des donn\u00e9es \u00e0 un objet de mani\u00e8re dynamique. Exemple : class Livre: def __init__(self, titre): self.titre = titre # Cr\u00e9ation d'un objet livre1 = Livre(\"Python pour les D\u00e9butants\") # Ajout d'un attribut associ\u00e9 \u00e0 l'objet apr\u00e8s son instanciation livre1.auteur = \"John Doe\" # Utilisation de l'attribut associ\u00e9 \u00e0 l'objet print(livre1.auteur) # Affiche \"John Doe\" Quand utiliser les attributs associ\u00e9s \u00e0 l'objet ? Utilisez des attributs associ\u00e9s \u00e0 l'objet lorsque vous devez ajouter des donn\u00e9es \u00e0 un objet apr\u00e8s son instanciation. Cela peut \u00eatre pratique pour personnaliser des objets individuellement. En r\u00e9sum\u00e9, les attributs de classe sont partag\u00e9s par toutes les instances, les attributs d'instance sont sp\u00e9cifiques \u00e0 chaque objet, et les attributs associ\u00e9s \u00e0 l'objet permettent d'ajouter des donn\u00e9es dynamiquement. Choisissez le type d'attribut qui correspond le mieux \u00e0 vos besoins en fonction du contexte de votre programme.","title":"Attributs"},{"location":"poo/seance-1/attributs/#les-attributs","text":"Python prend en charge plusieurs types d'attributs, qui sont des variables associ\u00e9es \u00e0 des classes et \u00e0 des objets. Chacun de ces types d'attributs a des caract\u00e9ristiques distinctes et est utilis\u00e9 dans des contextes diff\u00e9rents. Les attributs peuvent \u00eatre class\u00e9s en trois cat\u00e9gories principales : les attributs de classe, les attributs d'instance et les attributs associ\u00e9s \u00e0 l'objet apr\u00e8s son instanciation.","title":"Les attributs"},{"location":"poo/seance-1/attributs/#attributs-de-classe","text":"Les attributs de classe sont partag\u00e9s par toutes les instances (objets) de la classe. Ils sont d\u00e9finis \u00e0 l'int\u00e9rieur de la classe, en dehors des m\u00e9thodes, et ne sont pas li\u00e9s \u00e0 une instance sp\u00e9cifique. Les attributs de classe sont g\u00e9n\u00e9ralement utilis\u00e9s pour stocker des informations qui sont partag\u00e9es par toutes les instances de la classe. Exemple : class Compteur: count = 0 # Attribut de classe def __init__(self): Compteur.count += 1 # Incr\u00e9mente l'attribut de classe # lors de la cr\u00e9ation d'une instance # Utilisation des attributs de classe objet1 = Compteur() print(Compteur.count) # Affiche 1 objet2 = Compteur() print(Compteur.count) # Affiche 2 Quand utiliser les attributs de classe ? Utilisez des attributs de classe lorsque vous avez besoin de stocker des donn\u00e9es qui sont partag\u00e9es par toutes les instances de la classe, comme un compteur global.","title":"Attributs de Classe"},{"location":"poo/seance-1/attributs/#attributs-dinstance","text":"Les attributs d'instance sont sp\u00e9cifiques \u00e0 chaque instance de la classe. Chaque objet a sa propre copie des attributs d'instance. Ils sont g\u00e9n\u00e9ralement d\u00e9finis dans le constructeur de la classe ( __init__ ) en utilisant le pr\u00e9fixe self . Les attributs d'instance sont utilis\u00e9s pour stocker des donn\u00e9es sp\u00e9cifiques \u00e0 chaque objet. Exemple : class Personne: def __init__(self, nom, age): self.nom = nom # Attribut d'instance self.age = age # Attribut d'instance # Utilisation des attributs d'instance personne1 = Personne(\"Alice\", 30) print(personne1.nom) # Affiche \"Alice\" print(personne1.age) # Affiche 30 personne2 = Personne(\"Bob\", 25) print(personne2.nom) # Affiche \"Bob\" print(personne2.age) # Affiche 25 Quand utiliser les attributs d'instance ? Utilisez des attributs d'instance lorsque vous devez stocker des donn\u00e9es sp\u00e9cifiques \u00e0 chaque objet, telles que les caract\u00e9ristiques individuelles d'une personne.","title":"Attributs d'Instance"},{"location":"poo/seance-1/attributs/#attributs-associes-a-lobjet-apres-son-instanciation","text":"En Python, vous pouvez ajouter des attributs \u00e0 un objet apr\u00e8s son instanciation. Ces attributs ne sont pas d\u00e9finis dans la classe ou le constructeur, mais ils sont attach\u00e9s \u00e0 l'objet \u00e0 la vol\u00e9e. Cette flexibilit\u00e9 est utile lorsque vous avez besoin d'ajouter des donn\u00e9es \u00e0 un objet de mani\u00e8re dynamique. Exemple : class Livre: def __init__(self, titre): self.titre = titre # Cr\u00e9ation d'un objet livre1 = Livre(\"Python pour les D\u00e9butants\") # Ajout d'un attribut associ\u00e9 \u00e0 l'objet apr\u00e8s son instanciation livre1.auteur = \"John Doe\" # Utilisation de l'attribut associ\u00e9 \u00e0 l'objet print(livre1.auteur) # Affiche \"John Doe\" Quand utiliser les attributs associ\u00e9s \u00e0 l'objet ? Utilisez des attributs associ\u00e9s \u00e0 l'objet lorsque vous devez ajouter des donn\u00e9es \u00e0 un objet apr\u00e8s son instanciation. Cela peut \u00eatre pratique pour personnaliser des objets individuellement. En r\u00e9sum\u00e9, les attributs de classe sont partag\u00e9s par toutes les instances, les attributs d'instance sont sp\u00e9cifiques \u00e0 chaque objet, et les attributs associ\u00e9s \u00e0 l'objet permettent d'ajouter des donn\u00e9es dynamiquement. Choisissez le type d'attribut qui correspond le mieux \u00e0 vos besoins en fonction du contexte de votre programme.","title":"Attributs Associ\u00e9s \u00e0 l'Objet apr\u00e8s son Instanciation"},{"location":"poo/seance-1/classes-objets/","text":"Syntaxe de Base de la POO en Python Introduction aux classes et aux objets Dans cette premi\u00e8re s\u00e9ance, nous aborderons les concepts de base de la programmation orient\u00e9e objet en Python. Commen\u00e7ons par comprendre ce que sont les classes et les objets. Les classes Une classe est un mod\u00e8le ou un plan pour cr\u00e9er des objets. Elle d\u00e9finit les attributs (variables) et les m\u00e9thodes (fonctions) que les objets de cette classe auront. En Python, vous pouvez cr\u00e9er une classe en utilisant le mot-cl\u00e9 class . Exemple de d\u00e9finition d'une classe simple : class Personne: def __init__(self, nom, age): self.nom = nom self.age = age Les objets Un objet est une instance d'une classe. C'est une entit\u00e9 concr\u00e8te qui poss\u00e8de des attributs et peut ex\u00e9cuter des m\u00e9thodes. Pour cr\u00e9er un objet \u00e0 partir d'une classe, vous appelez le constructeur de la classe en utilisant la notation nom_de_classe() . Exemple de cr\u00e9ation d'un objet \u00e0 partir de la classe Personne : personne1 = Personne(\"Ahmed\", 30) personne2 = Personne(\"Sami\", 25) Cr\u00e9ation de classes et d'objets Maintenant que nous comprenons ce que sont les classes et les objets, passons \u00e0 la cr\u00e9ation pratique de classes et d'objets en Python. D\u00e9finition d'une classe Pour d\u00e9finir une classe, utilisez le mot-cl\u00e9 class , suivi du nom de la classe (en utilisant la convention CamelCase ) et du signe : . \u00c0 l'int\u00e9rieur de la classe, vous d\u00e9finirez les attributs et les m\u00e9thodes. Exemple de d\u00e9finition de classe : class Voiture: def __init__(self, marque, modele): self.marque = marque self.modele = modele Cr\u00e9ation d'objets Pour cr\u00e9er un objet \u00e0 partir d'une classe, appelez le constructeur de la classe en utilisant la notation nom_de_classe() . Vous pouvez passer des arguments au constructeur pour initialiser les attributs de l'objet. Exemple de cr\u00e9ation d'objets \u00e0 partir de la classe Voiture : voiture1 = Voiture(\"Toyota\", \"Camry\") voiture2 = Voiture(\"Honda\", \"Civic\") Acc\u00e8s aux attributs Vous pouvez acc\u00e9der aux attributs d'un objet en utilisant la notation point objet.attribut . Par exemple : print(voiture1.marque) # Affiche \"Toyota\" print(voiture2.modele) # Affiche \"Civic\" Utilisation de m\u00e9thodes Les m\u00e9thodes sont des fonctions d\u00e9finies \u00e0 l'int\u00e9rieur de la classe et peuvent \u00eatre appel\u00e9es sur les objets de cette classe. Elles sont utiles pour effectuer des op\u00e9rations sp\u00e9cifiques sur les objets. Exemple de m\u00e9thode dans la classe Voiture : class Voiture: def __init__(self, marque, modele): self.marque = marque self.modele = modele def description(self): return \"{} {}\".format(self.marque, self.modele) Utilisation de la m\u00e9thode description : voiture1 = Voiture(\"Toyota\", \"Camry\") print(voiture1.description()) # Affiche \"Toyota Camry\" Dans cette premi\u00e8re partie, nous avons explor\u00e9 la cr\u00e9ation de classes et d'objets en Python, ainsi que l'acc\u00e8s aux attributs et l'utilisation de m\u00e9thodes. Dans les parties suivantes, nous approfondirons d'autres aspects de la programmation orient\u00e9e objet.","title":"Classes et objets"},{"location":"poo/seance-1/classes-objets/#syntaxe-de-base-de-la-poo-en-python","text":"","title":"Syntaxe de Base de la POO en Python"},{"location":"poo/seance-1/classes-objets/#introduction-aux-classes-et-aux-objets","text":"Dans cette premi\u00e8re s\u00e9ance, nous aborderons les concepts de base de la programmation orient\u00e9e objet en Python. Commen\u00e7ons par comprendre ce que sont les classes et les objets.","title":"Introduction aux classes et aux objets"},{"location":"poo/seance-1/classes-objets/#les-classes","text":"Une classe est un mod\u00e8le ou un plan pour cr\u00e9er des objets. Elle d\u00e9finit les attributs (variables) et les m\u00e9thodes (fonctions) que les objets de cette classe auront. En Python, vous pouvez cr\u00e9er une classe en utilisant le mot-cl\u00e9 class . Exemple de d\u00e9finition d'une classe simple : class Personne: def __init__(self, nom, age): self.nom = nom self.age = age","title":"Les classes"},{"location":"poo/seance-1/classes-objets/#les-objets","text":"Un objet est une instance d'une classe. C'est une entit\u00e9 concr\u00e8te qui poss\u00e8de des attributs et peut ex\u00e9cuter des m\u00e9thodes. Pour cr\u00e9er un objet \u00e0 partir d'une classe, vous appelez le constructeur de la classe en utilisant la notation nom_de_classe() . Exemple de cr\u00e9ation d'un objet \u00e0 partir de la classe Personne : personne1 = Personne(\"Ahmed\", 30) personne2 = Personne(\"Sami\", 25)","title":"Les objets"},{"location":"poo/seance-1/classes-objets/#creation-de-classes-et-dobjets","text":"Maintenant que nous comprenons ce que sont les classes et les objets, passons \u00e0 la cr\u00e9ation pratique de classes et d'objets en Python.","title":"Cr\u00e9ation de classes et d'objets"},{"location":"poo/seance-1/classes-objets/#definition-dune-classe","text":"Pour d\u00e9finir une classe, utilisez le mot-cl\u00e9 class , suivi du nom de la classe (en utilisant la convention CamelCase ) et du signe : . \u00c0 l'int\u00e9rieur de la classe, vous d\u00e9finirez les attributs et les m\u00e9thodes. Exemple de d\u00e9finition de classe : class Voiture: def __init__(self, marque, modele): self.marque = marque self.modele = modele","title":"D\u00e9finition d'une classe"},{"location":"poo/seance-1/classes-objets/#creation-dobjets","text":"Pour cr\u00e9er un objet \u00e0 partir d'une classe, appelez le constructeur de la classe en utilisant la notation nom_de_classe() . Vous pouvez passer des arguments au constructeur pour initialiser les attributs de l'objet. Exemple de cr\u00e9ation d'objets \u00e0 partir de la classe Voiture : voiture1 = Voiture(\"Toyota\", \"Camry\") voiture2 = Voiture(\"Honda\", \"Civic\")","title":"Cr\u00e9ation d'objets"},{"location":"poo/seance-1/classes-objets/#acces-aux-attributs","text":"Vous pouvez acc\u00e9der aux attributs d'un objet en utilisant la notation point objet.attribut . Par exemple : print(voiture1.marque) # Affiche \"Toyota\" print(voiture2.modele) # Affiche \"Civic\"","title":"Acc\u00e8s aux attributs"},{"location":"poo/seance-1/classes-objets/#utilisation-de-methodes","text":"Les m\u00e9thodes sont des fonctions d\u00e9finies \u00e0 l'int\u00e9rieur de la classe et peuvent \u00eatre appel\u00e9es sur les objets de cette classe. Elles sont utiles pour effectuer des op\u00e9rations sp\u00e9cifiques sur les objets. Exemple de m\u00e9thode dans la classe Voiture : class Voiture: def __init__(self, marque, modele): self.marque = marque self.modele = modele def description(self): return \"{} {}\".format(self.marque, self.modele) Utilisation de la m\u00e9thode description : voiture1 = Voiture(\"Toyota\", \"Camry\") print(voiture1.description()) # Affiche \"Toyota Camry\" Dans cette premi\u00e8re partie, nous avons explor\u00e9 la cr\u00e9ation de classes et d'objets en Python, ainsi que l'acc\u00e8s aux attributs et l'utilisation de m\u00e9thodes. Dans les parties suivantes, nous approfondirons d'autres aspects de la programmation orient\u00e9e objet.","title":"Utilisation de m\u00e9thodes"},{"location":"poo/seance-1/constructeur-destructeur/","text":"Les Constructeurs et Destructeurs en Python En Python, les constructeurs et les destructeurs sont des m\u00e9thodes sp\u00e9ciales qui sont utilis\u00e9es pour initialiser et lib\u00e9rer des ressources associ\u00e9es \u00e0 un objet. Ils sont couramment utilis\u00e9s dans la programmation orient\u00e9e objet pour personnaliser le comportement des classes. Le Constructeur __init__ Le constructeur est une m\u00e9thode sp\u00e9ciale appel\u00e9e automatiquement lors de la cr\u00e9ation d'un objet \u00e0 partir d'une classe. Il est utilis\u00e9 pour initialiser les attributs de l'objet et effectuer d'autres op\u00e9rations d'initialisation. Le nom de la m\u00e9thode doit \u00eatre __init__ . Exemple de constructeur : class Personne: def __init__(self, nom, age): self.nom = nom self.age = age Dans cet exemple, le constructeur __init__ prend deux param\u00e8tres ( self , qui fait r\u00e9f\u00e9rence \u00e0 l'objet lui-m\u00eame, ainsi que nom et age) et initialise les attributs nom et age de l'objet. Le Destructeur __del__ Le destructeur est une autre m\u00e9thode sp\u00e9ciale appel\u00e9e automatiquement lorsque l'objet n'a plus de r\u00e9f\u00e9rences et doit \u00eatre d\u00e9truit. Il est utilis\u00e9 pour effectuer des op\u00e9rations de nettoyage ou de lib\u00e9ration de ressources. Le nom de la m\u00e9thode doit \u00eatre __del__ . Exemple de destructeur (\u00e0 titre d'illustration) : class Fichier: def __init__(self, nom): self.nom = nom print(\"Le fichier \" + self.nom + \" a \u00e9t\u00e9 cr\u00e9\u00e9.\") def __del__(self): print(\"Le fichier \" + self.nom + \" a \u00e9t\u00e9 supprim\u00e9\") f = Fichier(\"mon_fichier.txt\") print(f.nom) # A la fin du script toutes les instances sont d\u00e9truites (via __del__) Dans cet exemple, le destructeur __del__ imprime un message lorsque l'objet de la classe Fichier est d\u00e9truit. Utilisation des Constructeurs et Destructeurs Les constructeurs sont utilis\u00e9s pour initialiser les attributs de l'objet lors de sa cr\u00e9ation, tandis que les destructeurs sont utilis\u00e9s pour effectuer des op\u00e9rations de nettoyage lorsque l'objet n'est plus n\u00e9cessaire. Les destructeurs ne sont pas toujours n\u00e9cessaires, car Python g\u00e8re automatiquement la gestion de la m\u00e9moire, mais ils peuvent \u00eatre utiles pour lib\u00e9rer des ressources externes. # Utilisation des constructeurs personne = Personne(\"Alice\", 30) # Utilisation des destructeurs (\u00e0 titre d'illustration) fichier = Fichier(\"mon_fichier.txt\") del fichier # Appel du destructeur pour lib\u00e9rer la ressource Les constructeurs et destructeurs sont des outils puissants pour personnaliser le comportement des classes en Python, en leur permettant d'effectuer des op\u00e9rations d'initialisation et de nettoyage sp\u00e9cifiques. En r\u00e9sum\u00e9, le constructeur __init__ est utilis\u00e9 pour initialiser les attributs de l'objet lors de sa cr\u00e9ation, tandis que le destructeur __del__ est utilis\u00e9 pour effectuer des op\u00e9rations de nettoyage lorsque l'objet est d\u00e9truit. Ces m\u00e9thodes sp\u00e9ciales sont couramment utilis\u00e9es en programmation orient\u00e9e objet en Python.","title":"Constructeurs et destructeurs"},{"location":"poo/seance-1/constructeur-destructeur/#les-constructeurs-et-destructeurs-en-python","text":"En Python, les constructeurs et les destructeurs sont des m\u00e9thodes sp\u00e9ciales qui sont utilis\u00e9es pour initialiser et lib\u00e9rer des ressources associ\u00e9es \u00e0 un objet. Ils sont couramment utilis\u00e9s dans la programmation orient\u00e9e objet pour personnaliser le comportement des classes.","title":"Les Constructeurs et Destructeurs en Python"},{"location":"poo/seance-1/constructeur-destructeur/#le-constructeur-__init__","text":"Le constructeur est une m\u00e9thode sp\u00e9ciale appel\u00e9e automatiquement lors de la cr\u00e9ation d'un objet \u00e0 partir d'une classe. Il est utilis\u00e9 pour initialiser les attributs de l'objet et effectuer d'autres op\u00e9rations d'initialisation. Le nom de la m\u00e9thode doit \u00eatre __init__ . Exemple de constructeur : class Personne: def __init__(self, nom, age): self.nom = nom self.age = age Dans cet exemple, le constructeur __init__ prend deux param\u00e8tres ( self , qui fait r\u00e9f\u00e9rence \u00e0 l'objet lui-m\u00eame, ainsi que nom et age) et initialise les attributs nom et age de l'objet.","title":"Le Constructeur __init__"},{"location":"poo/seance-1/constructeur-destructeur/#le-destructeur-__del__","text":"Le destructeur est une autre m\u00e9thode sp\u00e9ciale appel\u00e9e automatiquement lorsque l'objet n'a plus de r\u00e9f\u00e9rences et doit \u00eatre d\u00e9truit. Il est utilis\u00e9 pour effectuer des op\u00e9rations de nettoyage ou de lib\u00e9ration de ressources. Le nom de la m\u00e9thode doit \u00eatre __del__ . Exemple de destructeur (\u00e0 titre d'illustration) : class Fichier: def __init__(self, nom): self.nom = nom print(\"Le fichier \" + self.nom + \" a \u00e9t\u00e9 cr\u00e9\u00e9.\") def __del__(self): print(\"Le fichier \" + self.nom + \" a \u00e9t\u00e9 supprim\u00e9\") f = Fichier(\"mon_fichier.txt\") print(f.nom) # A la fin du script toutes les instances sont d\u00e9truites (via __del__) Dans cet exemple, le destructeur __del__ imprime un message lorsque l'objet de la classe Fichier est d\u00e9truit.","title":"Le Destructeur __del__"},{"location":"poo/seance-1/constructeur-destructeur/#utilisation-des-constructeurs-et-destructeurs","text":"Les constructeurs sont utilis\u00e9s pour initialiser les attributs de l'objet lors de sa cr\u00e9ation, tandis que les destructeurs sont utilis\u00e9s pour effectuer des op\u00e9rations de nettoyage lorsque l'objet n'est plus n\u00e9cessaire. Les destructeurs ne sont pas toujours n\u00e9cessaires, car Python g\u00e8re automatiquement la gestion de la m\u00e9moire, mais ils peuvent \u00eatre utiles pour lib\u00e9rer des ressources externes. # Utilisation des constructeurs personne = Personne(\"Alice\", 30) # Utilisation des destructeurs (\u00e0 titre d'illustration) fichier = Fichier(\"mon_fichier.txt\") del fichier # Appel du destructeur pour lib\u00e9rer la ressource Les constructeurs et destructeurs sont des outils puissants pour personnaliser le comportement des classes en Python, en leur permettant d'effectuer des op\u00e9rations d'initialisation et de nettoyage sp\u00e9cifiques. En r\u00e9sum\u00e9, le constructeur __init__ est utilis\u00e9 pour initialiser les attributs de l'objet lors de sa cr\u00e9ation, tandis que le destructeur __del__ est utilis\u00e9 pour effectuer des op\u00e9rations de nettoyage lorsque l'objet est d\u00e9truit. Ces m\u00e9thodes sp\u00e9ciales sont couramment utilis\u00e9es en programmation orient\u00e9e objet en Python.","title":"Utilisation des Constructeurs et Destructeurs"},{"location":"poo/seance-1/exercices-corrige/","text":"TP1 POO : Syntaxe de Base de la POO en Python ~ Corrig\u00e9 Exercice 1 : Cr\u00e9er une classe simple class Personne: def __init__(self, nom): self.nom = nom # Instanciation d'un objet de la classe Personne personne1 = Personne(\"Alice\") # Affichage du nom de la personne print(\"Nom de la personne :\", personne1.nom) Exercice 2 : Cr\u00e9er une classe pour les voitures class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee # Instanciation de plusieurs objets de la classe Voiture voiture1 = Voiture(\"Toyota\", 2020) voiture2 = Voiture(\"Honda\", 2022) # Affichage des informations sur chaque voiture print(\"Voiture 1 - Marque :\", voiture1.marque, \"Ann\u00e9e :\", voiture1.annee) print(\"Voiture 2 - Marque :\", voiture2.marque, \"Ann\u00e9e :\", voiture2.annee) Exercice 3 : Ajouter des m\u00e9thodes class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee def afficher_info(self): print(\"Marque :\", self.marque) print(\"Ann\u00e9e :\", self.annee) # Instanciation de plusieurs objets de la classe Voiture voiture1 = Voiture(\"Toyota\", 2020) voiture2 = Voiture(\"Honda\", 2022) # Appel de la m\u00e9thode afficher_info pour chaque voiture print(\"Informations sur la voiture 1 :\") voiture1.afficher_info() print(\"Informations sur la voiture 2 :\") voiture2.afficher_info() Exercice 4 : Cr\u00e9er un constructeur param\u00e9trable class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee # Instanciation d'un objet de la classe Voiture avec des param\u00e8tres voiture = Voiture(\"Toyota\", 2020) # Affichage des informations sur la voiture print(\"Marque :\", voiture.marque) print(\"Ann\u00e9e :\", voiture.annee) Exercice 5 : Ajouter un destructeur class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee def __del__(self): print(f\"La voiture de marque {self.marque} a \u00e9t\u00e9 d\u00e9truite\") # Instanciation d'un objet de la classe Voiture voiture = Voiture(\"Toyota\", 2020) # Suppression de la r\u00e9f\u00e9rence \u00e0 l'objet pour d\u00e9clencher le destructeur del voiture Exercice 6 : Nettoyage des ressources class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee def __del__(self): print(f\"La voiture de marque {self.marque} de {self.annee} a \u00e9t\u00e9 d\u00e9truite\") def fermer_connexion(self): print(f\"Connexion ferm\u00e9e pour la voiture de marque {self.marque}\") # Instanciation d'un objet de la classe Voiture voiture = Voiture(\"Toyota\", 2020) # Utilisation du destructeur pour simuler la fermeture de la connexion voiture.fermer_connexion() # Simule la fermeture d'une connexion del voiture","title":"Programmation Orient\u00e9e Objet (POO) en Python"},{"location":"poo/seance-1/exercices-corrige/#tp1-poo-syntaxe-de-base-de-la-poo-en-python-corrige","text":"Exercice 1 : Cr\u00e9er une classe simple class Personne: def __init__(self, nom): self.nom = nom # Instanciation d'un objet de la classe Personne personne1 = Personne(\"Alice\") # Affichage du nom de la personne print(\"Nom de la personne :\", personne1.nom) Exercice 2 : Cr\u00e9er une classe pour les voitures class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee # Instanciation de plusieurs objets de la classe Voiture voiture1 = Voiture(\"Toyota\", 2020) voiture2 = Voiture(\"Honda\", 2022) # Affichage des informations sur chaque voiture print(\"Voiture 1 - Marque :\", voiture1.marque, \"Ann\u00e9e :\", voiture1.annee) print(\"Voiture 2 - Marque :\", voiture2.marque, \"Ann\u00e9e :\", voiture2.annee) Exercice 3 : Ajouter des m\u00e9thodes class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee def afficher_info(self): print(\"Marque :\", self.marque) print(\"Ann\u00e9e :\", self.annee) # Instanciation de plusieurs objets de la classe Voiture voiture1 = Voiture(\"Toyota\", 2020) voiture2 = Voiture(\"Honda\", 2022) # Appel de la m\u00e9thode afficher_info pour chaque voiture print(\"Informations sur la voiture 1 :\") voiture1.afficher_info() print(\"Informations sur la voiture 2 :\") voiture2.afficher_info() Exercice 4 : Cr\u00e9er un constructeur param\u00e9trable class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee # Instanciation d'un objet de la classe Voiture avec des param\u00e8tres voiture = Voiture(\"Toyota\", 2020) # Affichage des informations sur la voiture print(\"Marque :\", voiture.marque) print(\"Ann\u00e9e :\", voiture.annee) Exercice 5 : Ajouter un destructeur class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee def __del__(self): print(f\"La voiture de marque {self.marque} a \u00e9t\u00e9 d\u00e9truite\") # Instanciation d'un objet de la classe Voiture voiture = Voiture(\"Toyota\", 2020) # Suppression de la r\u00e9f\u00e9rence \u00e0 l'objet pour d\u00e9clencher le destructeur del voiture Exercice 6 : Nettoyage des ressources class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee def __del__(self): print(f\"La voiture de marque {self.marque} de {self.annee} a \u00e9t\u00e9 d\u00e9truite\") def fermer_connexion(self): print(f\"Connexion ferm\u00e9e pour la voiture de marque {self.marque}\") # Instanciation d'un objet de la classe Voiture voiture = Voiture(\"Toyota\", 2020) # Utilisation du destructeur pour simuler la fermeture de la connexion voiture.fermer_connexion() # Simule la fermeture d'une connexion del voiture","title":"TP1 POO : Syntaxe de Base de la POO en Python ~ Corrig\u00e9"},{"location":"poo/seance-1/exercices/","text":"TP1 POO : Syntaxe de Base de la POO en Python Cr\u00e9ation de classes et d'objets Exercice 1 : Cr\u00e9er une classe simple Cr\u00e9ez une classe Personne avec un attribut nom. Instanciez un objet de cette classe et affichez le nom de la personne. Attributs Exercice 2 : Cr\u00e9er une classe pour les voitures Cr\u00e9ez une classe Voiture avec les attributs marque et annee. Instanciez plusieurs objets de cette classe avec diff\u00e9rentes marques et ann\u00e9es et affichez les informations sur chaque voiture. M\u00e9thodes Exercice 3 : Ajouter des m\u00e9thodes Ajoutez une m\u00e9thode afficher_info() \u00e0 la classe Voiture qui affiche les informations de la voiture. Appelez cette m\u00e9thode pour chaque objet de la classe Voiture que vous avez cr\u00e9\u00e9 dans l'exercice pr\u00e9c\u00e9dent. Constructeurs et destructeurs Exercice 4 : Cr\u00e9er un constructeur param\u00e9trable Ajouter des param\u00e8tres au constructeur ( __init__ ) de la classe Voiture pour initialiser les attributs marque et annee lors de la cr\u00e9ation de l'objet. Exercice 5 : Ajouter un destructeur Ajoutez un destructeur ( __del__ ) \u00e0 la classe Voiture qui affiche un message lorsque la voiture est d\u00e9truite. Exercice 6 : Nettoyage des ressources Utilisez le destructeur pour simuler la lib\u00e9ration de ressources associ\u00e9es \u00e0 une voiture (par exemple, fermez une connexion \u00e0 un fichier text). Affichez un message appropri\u00e9 lorsque la voiture est d\u00e9truite. Ce TP couvre les concepts de base de la POO en Python, de l'introduction aux classes et aux objets jusqu'\u00e0 la cr\u00e9ation de constructeurs et de destructeurs. Vous pouvez progresser \u00e0 votre propre rythme en r\u00e9solvant chaque exercice.","title":"Programmation Orient\u00e9e Objet (POO) en Python"},{"location":"poo/seance-1/exercices/#tp1-poo-syntaxe-de-base-de-la-poo-en-python","text":"","title":"TP1 POO : Syntaxe de Base de la POO en Python"},{"location":"poo/seance-1/exercices/#creation-de-classes-et-dobjets","text":"Exercice 1 : Cr\u00e9er une classe simple Cr\u00e9ez une classe Personne avec un attribut nom. Instanciez un objet de cette classe et affichez le nom de la personne.","title":"Cr\u00e9ation de classes et d'objets"},{"location":"poo/seance-1/exercices/#attributs","text":"Exercice 2 : Cr\u00e9er une classe pour les voitures Cr\u00e9ez une classe Voiture avec les attributs marque et annee. Instanciez plusieurs objets de cette classe avec diff\u00e9rentes marques et ann\u00e9es et affichez les informations sur chaque voiture.","title":"Attributs"},{"location":"poo/seance-1/exercices/#methodes","text":"Exercice 3 : Ajouter des m\u00e9thodes Ajoutez une m\u00e9thode afficher_info() \u00e0 la classe Voiture qui affiche les informations de la voiture. Appelez cette m\u00e9thode pour chaque objet de la classe Voiture que vous avez cr\u00e9\u00e9 dans l'exercice pr\u00e9c\u00e9dent.","title":"M\u00e9thodes"},{"location":"poo/seance-1/exercices/#constructeurs-et-destructeurs","text":"Exercice 4 : Cr\u00e9er un constructeur param\u00e9trable Ajouter des param\u00e8tres au constructeur ( __init__ ) de la classe Voiture pour initialiser les attributs marque et annee lors de la cr\u00e9ation de l'objet. Exercice 5 : Ajouter un destructeur Ajoutez un destructeur ( __del__ ) \u00e0 la classe Voiture qui affiche un message lorsque la voiture est d\u00e9truite. Exercice 6 : Nettoyage des ressources Utilisez le destructeur pour simuler la lib\u00e9ration de ressources associ\u00e9es \u00e0 une voiture (par exemple, fermez une connexion \u00e0 un fichier text). Affichez un message appropri\u00e9 lorsque la voiture est d\u00e9truite. Ce TP couvre les concepts de base de la POO en Python, de l'introduction aux classes et aux objets jusqu'\u00e0 la cr\u00e9ation de constructeurs et de destructeurs. Vous pouvez progresser \u00e0 votre propre rythme en r\u00e9solvant chaque exercice.","title":"Constructeurs et destructeurs"},{"location":"poo/seance-1/methodes/","text":"Les m\u00e9thodes Les m\u00e9thodes en Python sont des fonctions associ\u00e9es \u00e0 des classes et \u00e0 des objets. Il existe diff\u00e9rents types de m\u00e9thodes, chacun ayant son propre but et utilisation. Comprendre les distinctions entre ces types de m\u00e9thodes est essentiel pour la programmation orient\u00e9e objet. Les m\u00e9thodes peuvent \u00eatre class\u00e9es en trois cat\u00e9gories principales : les m\u00e9thodes de classe, les m\u00e9thodes d'instance et les m\u00e9thodes associ\u00e9s \u00e0 l'objet apr\u00e8s son instanciation. M\u00e9thodes d'Instance Les m\u00e9thodes d'instance sont des fonctions d\u00e9finies \u00e0 l'int\u00e9rieur d'une classe et qui sont appel\u00e9es sur des objets sp\u00e9cifiques de cette classe. Elles ont automatiquement acc\u00e8s aux attributs de l'objet via le param\u00e8tre self . Exemple : class Personne: def __init__(self, nom, age): self.nom = nom self.age = age def presenter(self): return \"Je m'appelle {} et j'ai {} ans.\".format(self.nom, self.age) # Utilisation des m\u00e9thodes d'instance personne1 = Personne(\"Alice\", 30) print(personne1.presenter()) # Appel de la m\u00e9thode sur l'objet Quand utiliser les m\u00e9thodes d'instance ? Utilisez des m\u00e9thodes d'instance lorsque vous devez effectuer des op\u00e9rations sp\u00e9cifiques \u00e0 un objet particulier, en utilisant ses attributs.","title":"M\u00e9thodes"},{"location":"poo/seance-1/methodes/#les-methodes","text":"Les m\u00e9thodes en Python sont des fonctions associ\u00e9es \u00e0 des classes et \u00e0 des objets. Il existe diff\u00e9rents types de m\u00e9thodes, chacun ayant son propre but et utilisation. Comprendre les distinctions entre ces types de m\u00e9thodes est essentiel pour la programmation orient\u00e9e objet. Les m\u00e9thodes peuvent \u00eatre class\u00e9es en trois cat\u00e9gories principales : les m\u00e9thodes de classe, les m\u00e9thodes d'instance et les m\u00e9thodes associ\u00e9s \u00e0 l'objet apr\u00e8s son instanciation.","title":"Les m\u00e9thodes"},{"location":"poo/seance-1/methodes/#methodes-dinstance","text":"Les m\u00e9thodes d'instance sont des fonctions d\u00e9finies \u00e0 l'int\u00e9rieur d'une classe et qui sont appel\u00e9es sur des objets sp\u00e9cifiques de cette classe. Elles ont automatiquement acc\u00e8s aux attributs de l'objet via le param\u00e8tre self . Exemple : class Personne: def __init__(self, nom, age): self.nom = nom self.age = age def presenter(self): return \"Je m'appelle {} et j'ai {} ans.\".format(self.nom, self.age) # Utilisation des m\u00e9thodes d'instance personne1 = Personne(\"Alice\", 30) print(personne1.presenter()) # Appel de la m\u00e9thode sur l'objet Quand utiliser les m\u00e9thodes d'instance ? Utilisez des m\u00e9thodes d'instance lorsque vous devez effectuer des op\u00e9rations sp\u00e9cifiques \u00e0 un objet particulier, en utilisant ses attributs.","title":"M\u00e9thodes d'Instance"},{"location":"poo/seance-2/exercices-corrige/","text":"TP1 POO : Syntaxe de Base de la POO en Python ~ Corrig\u00e9 Exercice 1 : Cr\u00e9er une classe simple class Personne: def __init__(self, nom): self.nom = nom # Instanciation d'un objet de la classe Personne personne1 = Personne(\"Alice\") # Affichage du nom de la personne print(\"Nom de la personne :\", personne1.nom) Exercice 2 : Cr\u00e9er une classe pour les voitures class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee # Instanciation de plusieurs objets de la classe Voiture voiture1 = Voiture(\"Toyota\", 2020) voiture2 = Voiture(\"Honda\", 2022) # Affichage des informations sur chaque voiture print(\"Voiture 1 - Marque :\", voiture1.marque, \"Ann\u00e9e :\", voiture1.annee) print(\"Voiture 2 - Marque :\", voiture2.marque, \"Ann\u00e9e :\", voiture2.annee) Exercice 3 : Ajouter des m\u00e9thodes class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee def afficher_info(self): print(\"Marque :\", self.marque) print(\"Ann\u00e9e :\", self.annee) # Instanciation de plusieurs objets de la classe Voiture voiture1 = Voiture(\"Toyota\", 2020) voiture2 = Voiture(\"Honda\", 2022) # Appel de la m\u00e9thode afficher_info pour chaque voiture print(\"Informations sur la voiture 1 :\") voiture1.afficher_info() print(\"Informations sur la voiture 2 :\") voiture2.afficher_info() Exercice 4 : Cr\u00e9er un constructeur param\u00e9trable class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee # Instanciation d'un objet de la classe Voiture avec des param\u00e8tres voiture = Voiture(\"Toyota\", 2020) # Affichage des informations sur la voiture print(\"Marque :\", voiture.marque) print(\"Ann\u00e9e :\", voiture.annee) Exercice 5 : Ajouter un destructeur class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee def __del__(self): print(f\"La voiture de marque {self.marque} a \u00e9t\u00e9 d\u00e9truite\") # Instanciation d'un objet de la classe Voiture voiture = Voiture(\"Toyota\", 2020) # Suppression de la r\u00e9f\u00e9rence \u00e0 l'objet pour d\u00e9clencher le destructeur del voiture Exercice 6 : Nettoyage des ressources class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee def __del__(self): print(f\"La voiture de marque {self.marque} de {self.annee} a \u00e9t\u00e9 d\u00e9truite\") def fermer_connexion(self): print(f\"Connexion ferm\u00e9e pour la voiture de marque {self.marque}\") # Instanciation d'un objet de la classe Voiture voiture = Voiture(\"Toyota\", 2020) # Utilisation du destructeur pour simuler la fermeture de la connexion voiture.fermer_connexion() # Simule la fermeture d'une connexion del voiture","title":"Programmation Orient\u00e9e Objet (POO) en Python"},{"location":"poo/seance-2/exercices-corrige/#tp1-poo-syntaxe-de-base-de-la-poo-en-python-corrige","text":"Exercice 1 : Cr\u00e9er une classe simple class Personne: def __init__(self, nom): self.nom = nom # Instanciation d'un objet de la classe Personne personne1 = Personne(\"Alice\") # Affichage du nom de la personne print(\"Nom de la personne :\", personne1.nom) Exercice 2 : Cr\u00e9er une classe pour les voitures class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee # Instanciation de plusieurs objets de la classe Voiture voiture1 = Voiture(\"Toyota\", 2020) voiture2 = Voiture(\"Honda\", 2022) # Affichage des informations sur chaque voiture print(\"Voiture 1 - Marque :\", voiture1.marque, \"Ann\u00e9e :\", voiture1.annee) print(\"Voiture 2 - Marque :\", voiture2.marque, \"Ann\u00e9e :\", voiture2.annee) Exercice 3 : Ajouter des m\u00e9thodes class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee def afficher_info(self): print(\"Marque :\", self.marque) print(\"Ann\u00e9e :\", self.annee) # Instanciation de plusieurs objets de la classe Voiture voiture1 = Voiture(\"Toyota\", 2020) voiture2 = Voiture(\"Honda\", 2022) # Appel de la m\u00e9thode afficher_info pour chaque voiture print(\"Informations sur la voiture 1 :\") voiture1.afficher_info() print(\"Informations sur la voiture 2 :\") voiture2.afficher_info() Exercice 4 : Cr\u00e9er un constructeur param\u00e9trable class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee # Instanciation d'un objet de la classe Voiture avec des param\u00e8tres voiture = Voiture(\"Toyota\", 2020) # Affichage des informations sur la voiture print(\"Marque :\", voiture.marque) print(\"Ann\u00e9e :\", voiture.annee) Exercice 5 : Ajouter un destructeur class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee def __del__(self): print(f\"La voiture de marque {self.marque} a \u00e9t\u00e9 d\u00e9truite\") # Instanciation d'un objet de la classe Voiture voiture = Voiture(\"Toyota\", 2020) # Suppression de la r\u00e9f\u00e9rence \u00e0 l'objet pour d\u00e9clencher le destructeur del voiture Exercice 6 : Nettoyage des ressources class Voiture: def __init__(self, marque, annee): self.marque = marque self.annee = annee def __del__(self): print(f\"La voiture de marque {self.marque} de {self.annee} a \u00e9t\u00e9 d\u00e9truite\") def fermer_connexion(self): print(f\"Connexion ferm\u00e9e pour la voiture de marque {self.marque}\") # Instanciation d'un objet de la classe Voiture voiture = Voiture(\"Toyota\", 2020) # Utilisation du destructeur pour simuler la fermeture de la connexion voiture.fermer_connexion() # Simule la fermeture d'une connexion del voiture","title":"TP1 POO : Syntaxe de Base de la POO en Python ~ Corrig\u00e9"},{"location":"poo/seance-2/exercices/","text":"TP1 POO : Syntaxe de Base de la POO en Python Cr\u00e9ation de classes et d'objets Exercice 1 : Cr\u00e9er une classe simple Cr\u00e9ez une classe Personne avec un attribut nom. Instanciez un objet de cette classe et affichez le nom de la personne. Attributs Exercice 2 : Cr\u00e9er une classe pour les voitures Cr\u00e9ez une classe Voiture avec les attributs marque et annee. Instanciez plusieurs objets de cette classe avec diff\u00e9rentes marques et ann\u00e9es et affichez les informations sur chaque voiture. M\u00e9thodes Exercice 3 : Ajouter des m\u00e9thodes Ajoutez une m\u00e9thode afficher_info() \u00e0 la classe Voiture qui affiche les informations de la voiture. Appelez cette m\u00e9thode pour chaque objet de la classe Voiture que vous avez cr\u00e9\u00e9 dans l'exercice pr\u00e9c\u00e9dent. Constructeurs et destructeurs Exercice 4 : Cr\u00e9er un constructeur param\u00e9trable Ajouter des param\u00e8tres au constructeur ( __init__ ) de la classe Voiture pour initialiser les attributs marque et annee lors de la cr\u00e9ation de l'objet. Exercice 5 : Ajouter un destructeur Ajoutez un destructeur ( __del__ ) \u00e0 la classe Voiture qui affiche un message lorsque la voiture est d\u00e9truite. Exercice 6 : Nettoyage des ressources Utilisez le destructeur pour simuler la lib\u00e9ration de ressources associ\u00e9es \u00e0 une voiture (par exemple, fermez une connexion \u00e0 un fichier text). Affichez un message appropri\u00e9 lorsque la voiture est d\u00e9truite. Ce TP couvre les concepts de base de la POO en Python, de l'introduction aux classes et aux objets jusqu'\u00e0 la cr\u00e9ation de constructeurs et de destructeurs. Vous pouvez progresser \u00e0 votre propre rythme en r\u00e9solvant chaque exercice.","title":"Programmation Orient\u00e9e Objet (POO) en Python"},{"location":"poo/seance-2/exercices/#tp1-poo-syntaxe-de-base-de-la-poo-en-python","text":"","title":"TP1 POO : Syntaxe de Base de la POO en Python"},{"location":"poo/seance-2/exercices/#creation-de-classes-et-dobjets","text":"Exercice 1 : Cr\u00e9er une classe simple Cr\u00e9ez une classe Personne avec un attribut nom. Instanciez un objet de cette classe et affichez le nom de la personne.","title":"Cr\u00e9ation de classes et d'objets"},{"location":"poo/seance-2/exercices/#attributs","text":"Exercice 2 : Cr\u00e9er une classe pour les voitures Cr\u00e9ez une classe Voiture avec les attributs marque et annee. Instanciez plusieurs objets de cette classe avec diff\u00e9rentes marques et ann\u00e9es et affichez les informations sur chaque voiture.","title":"Attributs"},{"location":"poo/seance-2/exercices/#methodes","text":"Exercice 3 : Ajouter des m\u00e9thodes Ajoutez une m\u00e9thode afficher_info() \u00e0 la classe Voiture qui affiche les informations de la voiture. Appelez cette m\u00e9thode pour chaque objet de la classe Voiture que vous avez cr\u00e9\u00e9 dans l'exercice pr\u00e9c\u00e9dent.","title":"M\u00e9thodes"},{"location":"poo/seance-2/exercices/#constructeurs-et-destructeurs","text":"Exercice 4 : Cr\u00e9er un constructeur param\u00e9trable Ajouter des param\u00e8tres au constructeur ( __init__ ) de la classe Voiture pour initialiser les attributs marque et annee lors de la cr\u00e9ation de l'objet. Exercice 5 : Ajouter un destructeur Ajoutez un destructeur ( __del__ ) \u00e0 la classe Voiture qui affiche un message lorsque la voiture est d\u00e9truite. Exercice 6 : Nettoyage des ressources Utilisez le destructeur pour simuler la lib\u00e9ration de ressources associ\u00e9es \u00e0 une voiture (par exemple, fermez une connexion \u00e0 un fichier text). Affichez un message appropri\u00e9 lorsque la voiture est d\u00e9truite. Ce TP couvre les concepts de base de la POO en Python, de l'introduction aux classes et aux objets jusqu'\u00e0 la cr\u00e9ation de constructeurs et de destructeurs. Vous pouvez progresser \u00e0 votre propre rythme en r\u00e9solvant chaque exercice.","title":"Constructeurs et destructeurs"},{"location":"poo/seance-2/heritage/","text":"H\u00e9ritage de classes Introduction L'h\u00e9ritage est une caract\u00e9ristique fondamentale de la programmation orient\u00e9e objet en Python, permettant de cr\u00e9er de nouvelles classes en se basant sur des classes existantes. L'h\u00e9ritage offre la possibilit\u00e9 de cr\u00e9er une classe enfant qui h\u00e9rite des attributs et des m\u00e9thodes d'une classe parente. Ce concept favorise la r\u00e9utilisation du code et la structuration des classes en hi\u00e9rarchies. Syntaxe de l'h\u00e9ritage En Python, l'h\u00e9ritage s'effectue en sp\u00e9cifiant la classe parente entre parenth\u00e8ses lors de la d\u00e9finition de la classe enfant. Par exemple : class Enfant(Parent): # Attributs et m\u00e9thodes sp\u00e9cifiques \u00e0 la classe enfant Exemple d'h\u00e9ritage Pour illustrer l'h\u00e9ritage, nous allons cr\u00e9er une classe \"Animal\" qui servira de classe parente, puis une classe \"Chien\" qui h\u00e9ritera des caract\u00e9ristiques de la classe \"Animal.\" # Cr\u00e9ation de la classe parente \"Animal\" class Animal: def __init__(self, nom, espece): self.nom = nom self.espece = espece def afficher_info(self): print(self.nom + \" est un \" + self.espece) # Cr\u00e9ation de la classe enfant \"Chien\" en utilisant l'h\u00e9ritage class Chien(Animal): def __init__(self, nom, race): # Appel du constructeur de la classe parente super().__init__(nom, espece=\"chien\") self.race = race # Red\u00e9finition de la m\u00e9thode afficher_info def afficher_info(self): print(self.nom + \" est un chien de race \" + self.race) # Cr\u00e9ation d'objets des classes Animal et Chien animal1 = Animal(\"Rex\", \"chien\") chien1 = Chien(\"Buddy\", \"Labrador\") # Appel de la m\u00e9thode afficher_info de chaque objet animal1.afficher_info() # Affiche \"Rex est un chien\" chien1.afficher_info() # Affiche \"Buddy est un chien de race Labrador\" Dans cet exemple, nous avons cr\u00e9\u00e9 une classe parente \"Animal\" avec des attributs \"nom\" et \"esp\u00e8ce\" ainsi qu'une m\u00e9thode \"afficher_info\". Ensuite, nous avons d\u00e9fini une classe enfant \"Chien\" en utilisant l'h\u00e9ritage de la classe \"Animal\". La classe \"Chien\" a son propre attribut \"race\" et red\u00e9finit la m\u00e9thode \"afficher_info\" pour afficher des informations sp\u00e9cifiques aux chiens. Enfin, nous avons cr\u00e9\u00e9 des objets des deux classes et appel\u00e9 la m\u00e9thode \"afficher_info\" pour chaque objet. Les avantages Les principaux avantages de l'h\u00e9ritage en programmation orient\u00e9e objet (POO) en Python sont les suivants : Avantage 1 : R\u00e9utilisation du code : L'h\u00e9ritage permet de r\u00e9utiliser les attributs et m\u00e9thodes d'une classe parente dans une classe enfant, \u00e9vitant ainsi la duplication de code . Avantage 2 : Cr\u00e9ation de hi\u00e9rarchies de classes : Vous pouvez cr\u00e9er une structure hi\u00e9rarchique de classes, o\u00f9 chaque classe enfant h\u00e9rite des fonctionnalit\u00e9s de la classe parente. Par exemple, une classe \"V\u00e9hicule\" peut \u00eatre la classe parente de \"Voiture\" et \"Moto\". Avantage 3 : Extensibilit\u00e9 : Vous pouvez ajouter de nouvelles fonctionnalit\u00e9s sp\u00e9cifiques \u00e0 une classe enfant tout en conservant les fonctionnalit\u00e9s h\u00e9rit\u00e9es de la classe parente. Avantage 4 : Modification centralis\u00e9e : Si vous devez apporter des modifications \u00e0 une fonctionnalit\u00e9 partag\u00e9e par plusieurs classes, vous pouvez le faire dans la classe parente, ce qui affectera automatiquement toutes les classes enfant. Avantage 5 : D\u00e9veloppement plus rapide : L'h\u00e9ritage acc\u00e9l\u00e8re le d\u00e9veloppement en r\u00e9duisant la quantit\u00e9 de code que vous devez \u00e9crire pour cr\u00e9er de nouvelles classes. Exemple : # Classe parente \"Animal\" class Animal: def __init__(self, nom, espece): self.nom = nom self.espece = espece def afficher_info(self): print(self.nom + \" est un \" + self.espece) # Classe enfant \"Chien\" h\u00e9ritant d'Animal class Chien(Animal): def __init__(self, nom, race): super().__init__(nom, espece=\"chien\") self.race = race def aboyer(self): print(self.nom + \" aboie\") # Sous-classe de Chien : ChienDomestique class ChienDomestique(Chien): def __init__(self, nom, race, proprietaire): super().__init__(nom, race) self.proprietaire = proprietaire def saluer_proprietaire(self): print(self.nom + \" salue son propri\u00e9taire \" + self.proprietaire) # Utilisation de l'h\u00e9ritage animal1 = Animal(\"Rex\", \"chien\") animal1.afficher_info() # Affiche \"Rex est un chien\" chien1 = Chien(\"Buddy\", \"Labrador\") chien1.afficher_info() # Affiche \"Buddy est un chien\" chien1.aboyer() # Avantage 3 : Extensibilit\u00e9 # Affiche \"Buddy aboie\" chien2 = ChienDomestique(\"Fido\", \"Terrier\", \"Alice\") chien2.afficher_info() chien2.saluer_proprietaire() Dans le code pr\u00e9dendent, gr\u00e2ce \u00e0 l'h\u00e9ritage, on a pu appliquer : La R\u00e9utilisation du code : La classe Chien r\u00e9utilise le constructeur ( __init__ ) de la classe parente Animal . Cela permet de ne pas avoir \u00e0 r\u00e9\u00e9crire le code pour initialiser les attributs nom et espece dans Chien . La Cr\u00e9ation de hi\u00e9rarchies de classes : L'avantage de la cr\u00e9ation de hi\u00e9rarchies de classes peut \u00eatre illustr\u00e9 par la possibilit\u00e9 de cr\u00e9er des classes enfant suppl\u00e9mentaires qui partagent des caract\u00e9ristiques communes avec la classe parente. Dans cet exemple, nous avons la classe ChienDomestique qui h\u00e9rite de la classe Chien , qui \u00e0 son tour h\u00e9rite de la classe Animal . La classe ChienDomestique ajoute un attribut proprietaire et une m\u00e9thode saluer_proprietaire , illustrant la hi\u00e9rarchie d'h\u00e9ritage. L' Extensibilit\u00e9 : En utilisant l'h\u00e9ritage, nous pouvons ajouter des m\u00e9thodes sp\u00e9cifiques aux sous-classes, comme la m\u00e9thode aboyer() , sans modifier la classe parente. Cela permet d'\u00e9tendre les fonctionnalit\u00e9s de mani\u00e8re modulaire. Dans cet exemple, l'appel \u00e0 aboyer() sur l'objet chien1 fonctionne sans avoir \u00e0 modifier la classe Animal ou Chien . La Modification centralis\u00e9e : Lorsque vous apportez des modifications \u00e0 la classe parente (par exemple, \u00e0 la m\u00e9thode afficher_info ), ces modifications se r\u00e9percutent automatiquement sur les classes enfants sans avoir \u00e0 les modifier individuellement. Le D\u00e9veloppement rapide : Lorsque vous cr\u00e9ez des classes enfants, vous n'avez pas besoin de r\u00e9\u00e9crire l'int\u00e9gralit\u00e9 du code de base de la classe parente. Cela acc\u00e9l\u00e8re le d\u00e9veloppement en r\u00e9duisant la quantit\u00e9 de code n\u00e9cessaire. Par exemple, dans la classe Chien , vous n'avez pas \u00e0 r\u00e9impl\u00e9menter la m\u00e9thode afficher_info car elle est d\u00e9j\u00e0 d\u00e9finie dans la classe parente Animal . Les pr\u00e9cautions \u00e0 prendre lors de l'utilisation de l'h\u00e9ritage La premi\u00e8re et principale pr\u00e9caution consiste \u00e0 bien planifier la hi\u00e9rarchie de classes. Il est essentiel de comprendre les relations entre les diff\u00e9rentes classes, de d\u00e9terminer quels attributs et m\u00e9thodes sont appropri\u00e9s pour chaque classe, et de s'assurer que l'h\u00e9ritage est utilis\u00e9 de mani\u00e8re logique. Il est important de n'utiliser l'h\u00e9ritage que lorsque cela est appropri\u00e9. L'h\u00e9ritage doit \u00eatre utilis\u00e9 pour mod\u00e9liser une relation \"est-un\" . Si une relation \"a-un\" est plus appropri\u00e9e, il est pr\u00e9f\u00e9rable d'utiliser la composition ou d'autres techniques. La relation \"est-un\" La relation \"est-un\" ( is-a ) est une relation d'h\u00e9ritage entre une classe de base (superclasse) et une classe d\u00e9riv\u00e9e (sous-classe). Elle indique que la sous-classe est une sp\u00e9cialisation de la superclasse, partageant certaines caract\u00e9ristiques de la superclasse tout en ajoutant des attributs et des m\u00e9thodes sp\u00e9cifiques. Dans notre exemple pr\u00e9c\u00e9dent, nous avons utilis\u00e9 une hi\u00e9rarchie de classes avec \"Animal\" comme classe de base. \"Chien\" et \"ChienDomestique\" sont des sous-classes qui h\u00e9ritent des attributs et des m\u00e9thodes d' \"Animal.\" Cette organisation refl\u00e8te la relation \"est-un\" : un chien est un animal, et un chien domestique est \u00e9galement un animal. Chacune de ces sous-classes partage des caract\u00e9ristiques communes de la classe parente, tout en pouvant d\u00e9finir des m\u00e9thodes sp\u00e9cifiques. La relation \"a-un\" La relation \"a-un\" ( has-a ) est une relation de composition entre deux classes, o\u00f9 une classe contient une instance d'une autre classe en tant qu'attribut. Cette relation indique qu'un objet de la classe contenant poss\u00e8de un objet de la classe contenue. Exemple: class Moteur: def __init__(self, type): self.type = type class Voiture: def __init__(self, marque, annee, moteur): self.marque = marque self.annee = annee self.moteur = moteur # Cr\u00e9ation d'instances moteur_voiture1 = Moteur(\"Essence\") voiture1 = Voiture(\"Toyota\", 2022, moteur_voiture1) # Utilisation de l'attribut de la relation \"a-un\" print(voiture1.moteur.type) # Affiche \"Essence\" Dans cet exemple, nous avons utilis\u00e9 la relation \"a-un\" pour mod\u00e9liser une voiture. La classe \"Voiture\" contient un attribut \"moteur,\" qui est une instance de la classe \"Moteur.\" Cette organisation refl\u00e8te la relation \"a-un\" : une voiture a un moteur. La classe \"Voiture\" poss\u00e8de les caract\u00e9ristiques d'une voiture (comme la marque et l'ann\u00e9e) tout en ayant un attribut sp\u00e9cifique, \"moteur.\" Cette approche nous permet de repr\u00e9senter la composition d'objets dans une structure plus complexe. Exercices Ces exercices illustrent diff\u00e9rentes utilisations de l'h\u00e9ritage et des relations \"est-un\" et \"a-un\" en Python: Cr\u00e9ez une nouvelle sous-classe de \"Chien\" appel\u00e9e \"ChienSportif\" avec un attribut \"vitesse\" et une m\u00e9thode \"courir()\" pour afficher la vitesse maximale de course. Cr\u00e9ez une instance de \"ChienSportif\" et appelez la m\u00e9thode \"courir()\". Modifiez la classe parente \"Animal\" en ajoutant un nouvel attribut (par exemple, \"poids\"). Assurez-vous que cette modification se refl\u00e8te automatiquement dans les sous-classes. Cr\u00e9ez une instance de \"Chien\" et v\u00e9rifiez si vous pouvez acc\u00e9der \u00e0 l'attribut \"poids\". Ajoutez une nouvelle sous-classe de \"ChienDomestique\" appel\u00e9e \"ChienGarde\" avec un attribut \"poste\" pour repr\u00e9senter le poste de garde du chien (par exemple, \"maison\" ou \"entreprise\"). Ajoutez une m\u00e9thode \"surveiller()\" pour que le chien de garde puisse signaler qu'il surveille son poste. Cr\u00e9ez une instance de \"ChienGarde\" et appelez la m\u00e9thode \"surveiller()\". Cr\u00e9ez une nouvelle classe \"MoteurElectrique\" avec un attribut \"batterie\" pour repr\u00e9senter le type de batterie (par exemple, \"lithium-ion\"). Ensuite, modifiez la classe \"Voiture\" pour inclure un attribut \"moteur_electrique\" qui sera une instance de la classe \"MoteurElectrique.\" Cr\u00e9ez une instance de \"Voiture\" avec un moteur \u00e9lectrique et acc\u00e9dez \u00e0 l'attribut \"batterie\" de la classe \"MoteurElectrique.\" Corrig\u00e9s Question 1 class ChienSportif(Chien): def __init__(self, nom, race, vitesse_max): super().__init__(nom, race) self.vitesse_max = vitesse_max def courir(self): print(self.nom + \" peut courir jusqu'\u00e0 \" + str(self.vitesse_max) + \" km/h\") chien_sportif1 = ChienSportif(\"Rocky\", \"Husky\", 40) chien_sportif1.courir() # Affiche \"Rocky peut courir jusqu'\u00e0 40 km/h\" Question 2 # Modification de la classe parente Animal class Animal: def __init__(self, nom, espece, poids): self.nom = nom self.espece = espece self.poids = poids # La classe Chien h\u00e9rite automatiquement de la modification nouveau_chien = Chien(\"Buddy\", \"Labrador\", 25) print(nouveau_chien.nom + \" est un \" + nouveau_chien.espece + \" pesant \" + str(nouveau_chien.poids) + \" kg\") Question 3 class ChienGarde(ChienDomestique): def __init__(self, nom, race, proprietaire, poste): super().__init__(nom, race, proprietaire) self.poste = poste def surveiller(self): print(self.nom + \" surveille le poste de \" + self.poste) chien_garde = ChienGarde(\"Max\", \"Berger Allemand\", \"Maison\", \"Jardin\") chien_garde.surveiller() # Affiche \"Max surveille le poste de Jardin\" Question 4 class MoteurElectrique: def __init__(self, batterie): self.batterie = batterie class Voiture: def __init__(self, marque, annee, moteur_electrique): self.marque = marque self.annee = annee self.moteur_electrique = moteur_electrique # Cr\u00e9ation d'instances moteur_electrique_voiture = MoteurElectrique(\"Lithium-ion\") voiture_electrique = Voiture(\"Tesla\", 2023, moteur_electrique_voiture) # Acc\u00e8s \u00e0 l'attribut \"batterie\" de la classe MoteurElectrique via la classe Voiture print(voiture_electrique.moteur_electrique.batterie) # Affiche \"Lithium-ion\"","title":"H\u00e9ritage de classes"},{"location":"poo/seance-2/heritage/#heritage-de-classes","text":"","title":"H\u00e9ritage de classes"},{"location":"poo/seance-2/heritage/#introduction","text":"L'h\u00e9ritage est une caract\u00e9ristique fondamentale de la programmation orient\u00e9e objet en Python, permettant de cr\u00e9er de nouvelles classes en se basant sur des classes existantes. L'h\u00e9ritage offre la possibilit\u00e9 de cr\u00e9er une classe enfant qui h\u00e9rite des attributs et des m\u00e9thodes d'une classe parente. Ce concept favorise la r\u00e9utilisation du code et la structuration des classes en hi\u00e9rarchies.","title":"Introduction"},{"location":"poo/seance-2/heritage/#syntaxe-de-lheritage","text":"En Python, l'h\u00e9ritage s'effectue en sp\u00e9cifiant la classe parente entre parenth\u00e8ses lors de la d\u00e9finition de la classe enfant. Par exemple : class Enfant(Parent): # Attributs et m\u00e9thodes sp\u00e9cifiques \u00e0 la classe enfant","title":"Syntaxe de l'h\u00e9ritage"},{"location":"poo/seance-2/heritage/#exemple-dheritage","text":"Pour illustrer l'h\u00e9ritage, nous allons cr\u00e9er une classe \"Animal\" qui servira de classe parente, puis une classe \"Chien\" qui h\u00e9ritera des caract\u00e9ristiques de la classe \"Animal.\" # Cr\u00e9ation de la classe parente \"Animal\" class Animal: def __init__(self, nom, espece): self.nom = nom self.espece = espece def afficher_info(self): print(self.nom + \" est un \" + self.espece) # Cr\u00e9ation de la classe enfant \"Chien\" en utilisant l'h\u00e9ritage class Chien(Animal): def __init__(self, nom, race): # Appel du constructeur de la classe parente super().__init__(nom, espece=\"chien\") self.race = race # Red\u00e9finition de la m\u00e9thode afficher_info def afficher_info(self): print(self.nom + \" est un chien de race \" + self.race) # Cr\u00e9ation d'objets des classes Animal et Chien animal1 = Animal(\"Rex\", \"chien\") chien1 = Chien(\"Buddy\", \"Labrador\") # Appel de la m\u00e9thode afficher_info de chaque objet animal1.afficher_info() # Affiche \"Rex est un chien\" chien1.afficher_info() # Affiche \"Buddy est un chien de race Labrador\" Dans cet exemple, nous avons cr\u00e9\u00e9 une classe parente \"Animal\" avec des attributs \"nom\" et \"esp\u00e8ce\" ainsi qu'une m\u00e9thode \"afficher_info\". Ensuite, nous avons d\u00e9fini une classe enfant \"Chien\" en utilisant l'h\u00e9ritage de la classe \"Animal\". La classe \"Chien\" a son propre attribut \"race\" et red\u00e9finit la m\u00e9thode \"afficher_info\" pour afficher des informations sp\u00e9cifiques aux chiens. Enfin, nous avons cr\u00e9\u00e9 des objets des deux classes et appel\u00e9 la m\u00e9thode \"afficher_info\" pour chaque objet.","title":"Exemple d'h\u00e9ritage"},{"location":"poo/seance-2/heritage/#les-avantages","text":"Les principaux avantages de l'h\u00e9ritage en programmation orient\u00e9e objet (POO) en Python sont les suivants : Avantage 1 : R\u00e9utilisation du code : L'h\u00e9ritage permet de r\u00e9utiliser les attributs et m\u00e9thodes d'une classe parente dans une classe enfant, \u00e9vitant ainsi la duplication de code . Avantage 2 : Cr\u00e9ation de hi\u00e9rarchies de classes : Vous pouvez cr\u00e9er une structure hi\u00e9rarchique de classes, o\u00f9 chaque classe enfant h\u00e9rite des fonctionnalit\u00e9s de la classe parente. Par exemple, une classe \"V\u00e9hicule\" peut \u00eatre la classe parente de \"Voiture\" et \"Moto\". Avantage 3 : Extensibilit\u00e9 : Vous pouvez ajouter de nouvelles fonctionnalit\u00e9s sp\u00e9cifiques \u00e0 une classe enfant tout en conservant les fonctionnalit\u00e9s h\u00e9rit\u00e9es de la classe parente. Avantage 4 : Modification centralis\u00e9e : Si vous devez apporter des modifications \u00e0 une fonctionnalit\u00e9 partag\u00e9e par plusieurs classes, vous pouvez le faire dans la classe parente, ce qui affectera automatiquement toutes les classes enfant. Avantage 5 : D\u00e9veloppement plus rapide : L'h\u00e9ritage acc\u00e9l\u00e8re le d\u00e9veloppement en r\u00e9duisant la quantit\u00e9 de code que vous devez \u00e9crire pour cr\u00e9er de nouvelles classes. Exemple : # Classe parente \"Animal\" class Animal: def __init__(self, nom, espece): self.nom = nom self.espece = espece def afficher_info(self): print(self.nom + \" est un \" + self.espece) # Classe enfant \"Chien\" h\u00e9ritant d'Animal class Chien(Animal): def __init__(self, nom, race): super().__init__(nom, espece=\"chien\") self.race = race def aboyer(self): print(self.nom + \" aboie\") # Sous-classe de Chien : ChienDomestique class ChienDomestique(Chien): def __init__(self, nom, race, proprietaire): super().__init__(nom, race) self.proprietaire = proprietaire def saluer_proprietaire(self): print(self.nom + \" salue son propri\u00e9taire \" + self.proprietaire) # Utilisation de l'h\u00e9ritage animal1 = Animal(\"Rex\", \"chien\") animal1.afficher_info() # Affiche \"Rex est un chien\" chien1 = Chien(\"Buddy\", \"Labrador\") chien1.afficher_info() # Affiche \"Buddy est un chien\" chien1.aboyer() # Avantage 3 : Extensibilit\u00e9 # Affiche \"Buddy aboie\" chien2 = ChienDomestique(\"Fido\", \"Terrier\", \"Alice\") chien2.afficher_info() chien2.saluer_proprietaire() Dans le code pr\u00e9dendent, gr\u00e2ce \u00e0 l'h\u00e9ritage, on a pu appliquer : La R\u00e9utilisation du code : La classe Chien r\u00e9utilise le constructeur ( __init__ ) de la classe parente Animal . Cela permet de ne pas avoir \u00e0 r\u00e9\u00e9crire le code pour initialiser les attributs nom et espece dans Chien . La Cr\u00e9ation de hi\u00e9rarchies de classes : L'avantage de la cr\u00e9ation de hi\u00e9rarchies de classes peut \u00eatre illustr\u00e9 par la possibilit\u00e9 de cr\u00e9er des classes enfant suppl\u00e9mentaires qui partagent des caract\u00e9ristiques communes avec la classe parente. Dans cet exemple, nous avons la classe ChienDomestique qui h\u00e9rite de la classe Chien , qui \u00e0 son tour h\u00e9rite de la classe Animal . La classe ChienDomestique ajoute un attribut proprietaire et une m\u00e9thode saluer_proprietaire , illustrant la hi\u00e9rarchie d'h\u00e9ritage. L' Extensibilit\u00e9 : En utilisant l'h\u00e9ritage, nous pouvons ajouter des m\u00e9thodes sp\u00e9cifiques aux sous-classes, comme la m\u00e9thode aboyer() , sans modifier la classe parente. Cela permet d'\u00e9tendre les fonctionnalit\u00e9s de mani\u00e8re modulaire. Dans cet exemple, l'appel \u00e0 aboyer() sur l'objet chien1 fonctionne sans avoir \u00e0 modifier la classe Animal ou Chien . La Modification centralis\u00e9e : Lorsque vous apportez des modifications \u00e0 la classe parente (par exemple, \u00e0 la m\u00e9thode afficher_info ), ces modifications se r\u00e9percutent automatiquement sur les classes enfants sans avoir \u00e0 les modifier individuellement. Le D\u00e9veloppement rapide : Lorsque vous cr\u00e9ez des classes enfants, vous n'avez pas besoin de r\u00e9\u00e9crire l'int\u00e9gralit\u00e9 du code de base de la classe parente. Cela acc\u00e9l\u00e8re le d\u00e9veloppement en r\u00e9duisant la quantit\u00e9 de code n\u00e9cessaire. Par exemple, dans la classe Chien , vous n'avez pas \u00e0 r\u00e9impl\u00e9menter la m\u00e9thode afficher_info car elle est d\u00e9j\u00e0 d\u00e9finie dans la classe parente Animal .","title":"Les avantages"},{"location":"poo/seance-2/heritage/#les-precautions-a-prendre-lors-de-lutilisation-de-lheritage","text":"La premi\u00e8re et principale pr\u00e9caution consiste \u00e0 bien planifier la hi\u00e9rarchie de classes. Il est essentiel de comprendre les relations entre les diff\u00e9rentes classes, de d\u00e9terminer quels attributs et m\u00e9thodes sont appropri\u00e9s pour chaque classe, et de s'assurer que l'h\u00e9ritage est utilis\u00e9 de mani\u00e8re logique. Il est important de n'utiliser l'h\u00e9ritage que lorsque cela est appropri\u00e9. L'h\u00e9ritage doit \u00eatre utilis\u00e9 pour mod\u00e9liser une relation \"est-un\" . Si une relation \"a-un\" est plus appropri\u00e9e, il est pr\u00e9f\u00e9rable d'utiliser la composition ou d'autres techniques.","title":"Les pr\u00e9cautions \u00e0 prendre lors de l'utilisation de l'h\u00e9ritage"},{"location":"poo/seance-2/heritage/#la-relation-est-un","text":"La relation \"est-un\" ( is-a ) est une relation d'h\u00e9ritage entre une classe de base (superclasse) et une classe d\u00e9riv\u00e9e (sous-classe). Elle indique que la sous-classe est une sp\u00e9cialisation de la superclasse, partageant certaines caract\u00e9ristiques de la superclasse tout en ajoutant des attributs et des m\u00e9thodes sp\u00e9cifiques. Dans notre exemple pr\u00e9c\u00e9dent, nous avons utilis\u00e9 une hi\u00e9rarchie de classes avec \"Animal\" comme classe de base. \"Chien\" et \"ChienDomestique\" sont des sous-classes qui h\u00e9ritent des attributs et des m\u00e9thodes d' \"Animal.\" Cette organisation refl\u00e8te la relation \"est-un\" : un chien est un animal, et un chien domestique est \u00e9galement un animal. Chacune de ces sous-classes partage des caract\u00e9ristiques communes de la classe parente, tout en pouvant d\u00e9finir des m\u00e9thodes sp\u00e9cifiques.","title":"La relation \"est-un\""},{"location":"poo/seance-2/heritage/#la-relation-a-un","text":"La relation \"a-un\" ( has-a ) est une relation de composition entre deux classes, o\u00f9 une classe contient une instance d'une autre classe en tant qu'attribut. Cette relation indique qu'un objet de la classe contenant poss\u00e8de un objet de la classe contenue. Exemple: class Moteur: def __init__(self, type): self.type = type class Voiture: def __init__(self, marque, annee, moteur): self.marque = marque self.annee = annee self.moteur = moteur # Cr\u00e9ation d'instances moteur_voiture1 = Moteur(\"Essence\") voiture1 = Voiture(\"Toyota\", 2022, moteur_voiture1) # Utilisation de l'attribut de la relation \"a-un\" print(voiture1.moteur.type) # Affiche \"Essence\" Dans cet exemple, nous avons utilis\u00e9 la relation \"a-un\" pour mod\u00e9liser une voiture. La classe \"Voiture\" contient un attribut \"moteur,\" qui est une instance de la classe \"Moteur.\" Cette organisation refl\u00e8te la relation \"a-un\" : une voiture a un moteur. La classe \"Voiture\" poss\u00e8de les caract\u00e9ristiques d'une voiture (comme la marque et l'ann\u00e9e) tout en ayant un attribut sp\u00e9cifique, \"moteur.\" Cette approche nous permet de repr\u00e9senter la composition d'objets dans une structure plus complexe.","title":"La relation \"a-un\""},{"location":"poo/seance-2/heritage/#exercices","text":"Ces exercices illustrent diff\u00e9rentes utilisations de l'h\u00e9ritage et des relations \"est-un\" et \"a-un\" en Python: Cr\u00e9ez une nouvelle sous-classe de \"Chien\" appel\u00e9e \"ChienSportif\" avec un attribut \"vitesse\" et une m\u00e9thode \"courir()\" pour afficher la vitesse maximale de course. Cr\u00e9ez une instance de \"ChienSportif\" et appelez la m\u00e9thode \"courir()\". Modifiez la classe parente \"Animal\" en ajoutant un nouvel attribut (par exemple, \"poids\"). Assurez-vous que cette modification se refl\u00e8te automatiquement dans les sous-classes. Cr\u00e9ez une instance de \"Chien\" et v\u00e9rifiez si vous pouvez acc\u00e9der \u00e0 l'attribut \"poids\". Ajoutez une nouvelle sous-classe de \"ChienDomestique\" appel\u00e9e \"ChienGarde\" avec un attribut \"poste\" pour repr\u00e9senter le poste de garde du chien (par exemple, \"maison\" ou \"entreprise\"). Ajoutez une m\u00e9thode \"surveiller()\" pour que le chien de garde puisse signaler qu'il surveille son poste. Cr\u00e9ez une instance de \"ChienGarde\" et appelez la m\u00e9thode \"surveiller()\". Cr\u00e9ez une nouvelle classe \"MoteurElectrique\" avec un attribut \"batterie\" pour repr\u00e9senter le type de batterie (par exemple, \"lithium-ion\"). Ensuite, modifiez la classe \"Voiture\" pour inclure un attribut \"moteur_electrique\" qui sera une instance de la classe \"MoteurElectrique.\" Cr\u00e9ez une instance de \"Voiture\" avec un moteur \u00e9lectrique et acc\u00e9dez \u00e0 l'attribut \"batterie\" de la classe \"MoteurElectrique.\"","title":"Exercices"},{"location":"poo/seance-2/heritage/#corriges","text":"Question 1 class ChienSportif(Chien): def __init__(self, nom, race, vitesse_max): super().__init__(nom, race) self.vitesse_max = vitesse_max def courir(self): print(self.nom + \" peut courir jusqu'\u00e0 \" + str(self.vitesse_max) + \" km/h\") chien_sportif1 = ChienSportif(\"Rocky\", \"Husky\", 40) chien_sportif1.courir() # Affiche \"Rocky peut courir jusqu'\u00e0 40 km/h\" Question 2 # Modification de la classe parente Animal class Animal: def __init__(self, nom, espece, poids): self.nom = nom self.espece = espece self.poids = poids # La classe Chien h\u00e9rite automatiquement de la modification nouveau_chien = Chien(\"Buddy\", \"Labrador\", 25) print(nouveau_chien.nom + \" est un \" + nouveau_chien.espece + \" pesant \" + str(nouveau_chien.poids) + \" kg\") Question 3 class ChienGarde(ChienDomestique): def __init__(self, nom, race, proprietaire, poste): super().__init__(nom, race, proprietaire) self.poste = poste def surveiller(self): print(self.nom + \" surveille le poste de \" + self.poste) chien_garde = ChienGarde(\"Max\", \"Berger Allemand\", \"Maison\", \"Jardin\") chien_garde.surveiller() # Affiche \"Max surveille le poste de Jardin\" Question 4 class MoteurElectrique: def __init__(self, batterie): self.batterie = batterie class Voiture: def __init__(self, marque, annee, moteur_electrique): self.marque = marque self.annee = annee self.moteur_electrique = moteur_electrique # Cr\u00e9ation d'instances moteur_electrique_voiture = MoteurElectrique(\"Lithium-ion\") voiture_electrique = Voiture(\"Tesla\", 2023, moteur_electrique_voiture) # Acc\u00e8s \u00e0 l'attribut \"batterie\" de la classe MoteurElectrique via la classe Voiture print(voiture_electrique.moteur_electrique.batterie) # Affiche \"Lithium-ion\"","title":"Corrig\u00e9s"},{"location":"poo/seance-2/polymorphisme/","text":"Le Polymorphisme en Python Le polymorphisme est l'un des principes fondamentaux de la programmation orient\u00e9e objet (POO) qui permet \u00e0 des objets de diff\u00e9rentes classes d'\u00eatre trait\u00e9s de mani\u00e8re uniforme. Cela signifie que vous pouvez utiliser des m\u00e9thodes ou des op\u00e9rateurs sur ces objets sans vous soucier de leur type sp\u00e9cifique. En Python, le polymorphisme est largement pris en charge gr\u00e2ce \u00e0 la flexibilit\u00e9 du langage. Comprendre le Polymorphisme Le polymorphisme peut \u00eatre divis\u00e9 en deux types principaux : le polymorphisme de m\u00e9thode et le polymorphisme d'op\u00e9rateur. Polymorphisme de M\u00e9thode Le polymorphisme de m\u00e9thode vous permet d'appeler une m\u00e9thode sur un objet, et la m\u00e9thode ex\u00e9cut\u00e9e d\u00e9pend du type de cet objet . Par exemple, supposons que nous ayons deux classes, Chien et Chat , chacune ayant une m\u00e9thode crier : class Chien: def crier(self): return \"Woof!\" class Chat: def crier(self): return \"Miaou!\" Maintenant, nous pouvons cr\u00e9er des objets de ces classes et appeler la m\u00e9thode crier : chien = Chien() chat = Chat() animaux = [chien, chat] for animal in animaux: print(animal.crier()) Lorsque nous appelons crier sur chaque objet, la m\u00e9thode appropri\u00e9e est appel\u00e9e en fonction du type de l'objet. Polymorphisme d'Op\u00e9rateur Le polymorphisme d'op\u00e9rateur permet d'utiliser des op\u00e9rateurs sur des objets de diff\u00e9rentes classes. Par exemple, vous pouvez utiliser l'op\u00e9rateur + pour concat\u00e9ner des cha\u00eenes de caract\u00e8res, mais aussi pour ajouter des nombres : a = 5 b = 10 resultat = a + b print(resultat) # Affiche 15 chaine1 = \"Hello, \" chaine2 = \"world!\" resultat = chaine1 + chaine2 print(resultat) # Affiche \"Hello, world!\" Python permet d'utiliser de nombreux op\u00e9rateurs de cette mani\u00e8re, tant que les classes d\u00e9finissent les m\u00e9thodes sp\u00e9ciales appropri\u00e9es, comme __add__ , __sub__ , etc. Avantages du Polymorphisme Le polymorphisme pr\u00e9sente plusieurs avantages : Flexibilit\u00e9 : Vous pouvez traiter diff\u00e9rents objets de mani\u00e8re uniforme, ce qui simplifie le code. Exemple : class Animal: def __init__(self, nom): self.nom = nom def faire_crier(self): pass class Chien(Animal): def faire_crier(self): return \"Woof!\" class Chat(Animal): def faire_crier(self): return \"Miaou!\" # Utilisation de la flexibilit\u00e9 du polymorphisme def faire_crier_et_afficher(animal): print(\"{} fait {}\".format(animal.nom, animal.faire_crier())) animaux = [Chien(\"Rex\"), Chat(\"Whiskers\")] for animal in animaux: faire_crier_et_afficher(animal) Dans cet exemple, nous utilisons le polymorphisme pour appeler la m\u00e9thode faire_crier sur des objets de diff\u00e9rentes classes, ce qui permet \u00e0 chaque animal de faire le bruit appropri\u00e9. R\u00e9utilisation du Code : Vous pouvez r\u00e9utiliser des m\u00e9thodes ou des op\u00e9rateurs sur des objets de diff\u00e9rentes classes. Exemple : class Forme: def aire(self): pass class Cercle(Forme): def __init__(self, rayon): self.rayon = rayon def aire(self): return 3.14159265359 * self.rayon * self.rayon class Rectangle(Forme): def __init(self, longueur, largeur): self.longueur = longueur self.largeur = largeur def aire(self): return self.longueur * self.largeur # Utilisation de la r\u00e9utilisation du code via le polymorphisme cercle = Cercle(5) rectangle = Rectangle(4, 6) formes = [cercle, rectangle] for forme in formes: print(f\"L'aire de la forme est {forme.*aire()*}\") Extension Facile : Vous pouvez \u00e9tendre le polymorphisme pour prendre en charge de nouvelles classes sans modifier le code existant. Exemple : # Nouvelle classe Triangle class Triangle(Forme): def __init__(self, base, hauteur): self.base = base self.hauteur = hauteur def aire(self): return 0.5 * self.base * self.hauteur triangle = Triangle(3, 4) # Sans modifier le code existant, nous pouvons ajouter un triangle \u00e0 la liste des formes formes.append(triangle) for forme in formes: print(f\"L'aire de la forme est {forme.*aire()*}\") Exercices Exercice 1 : Calcul d'aire de formes g\u00e9om\u00e9triques \u00c9crivez une classe de base appel\u00e9e Forme avec une m\u00e9thode aire() . Ensuite, cr\u00e9ez trois sous-classes de Forme : Cercle , Rectangle , et Triangle , chacune avec sa propre impl\u00e9mentation de la m\u00e9thode aire() . Enfin, cr\u00e9ez une liste de formes contenant des instances de ces trois sous-classes. Calculez et affichez l'aire de chaque forme \u00e0 partir de la liste. Solution class Forme(): def aire(self): pass class Cercle(Forme): def __init__(self, rayon): self.rayon = rayon def aire(self): return 3.14159265359 * self.rayon * self.rayon class Rectangle(Forme): def __init__(self, longueur, largeur): self.longueur = longueur self.largeur = largeur def aire(self): return self.longueur * self.largeur class Triangle(Forme): def __init__(self, base, hauteur): self.base = base self.hauteur = hauteur def aire(self): return 0.5 * self.base * self.hauteur # Cr\u00e9ation d'une liste de formes formes = [Cercle(5), Rectangle(4, 6), Triangle(3, 4)] # Calcul et affichage de l'aire de chaque forme for forme in formes: print(\"L'aire de la forme est \"+str(forme.aire())) # R\u00e9sultat attendu : # L'aire du cercle est 78.53981633974483 # L'aire du rectangle est 24 # L'aire du triangle est 6.0 Exercice 2 : Polymorphisme avec des v\u00e9hicules Cr\u00e9ez une classe de base appel\u00e9e Vehicule avec une m\u00e9thode afficher_info qui affiche des informations de base sur le v\u00e9hicule, telles que le nom du v\u00e9hicule. Cr\u00e9ez trois sous-classes de Vehicule : Voiture , Moto , et Velo , chacune avec son propre constructeur et des informations sp\u00e9cifiques (par exemple, le nombre de roues pour chaque type de v\u00e9hicule). Instanciez plusieurs v\u00e9hicules de chaque type (voiture, moto, v\u00e9lo) et stockez-les dans une liste. Utilisez le polymorphisme pour appeler la m\u00e9thode afficher_info pour chaque v\u00e9hicule de la liste, affichant ainsi des informations sp\u00e9cifiques \u00e0 chaque type de v\u00e9hicule. Solution class Vehicule: def __init__(self, nom): self.nom = nom def afficher_info(self): print(\"V\u00e9hicule : {}\".format(self.nom)) class Voiture(Vehicule): def __init__(self, nom, roues): super().__init__(nom) self.roues = roues def afficher_info(self): print(\"Voiture : {}, Roues : {}\".format(self.nom, self.roues)) class Moto(Vehicule): def __init__(self, nom, roues): super().__init__(nom) self.roues = roues def afficher_info(self): print(\"Moto : {}, Roues : {}\".format(self.nom, self.roues)) class Velo(Vehicule): def __init__(self, nom, roues): super().__init__(nom) self.roues = roues def afficher_info(self): print(\"V\u00e9lo : {}, Roues : {}\".format(self.nom, self.roues)) # Cr\u00e9ation d'une liste de v\u00e9hicules vehicules = [Voiture(\"Sedan\", 4), Moto(\"Sportive\", 2), Velo(\"Montagne\", 2), Voiture(\"Compacte\", 4)] # Utilisation du polymorphisme pour afficher les informations de chaque v\u00e9hicule for vehicule in vehicules: vehicule.afficher_info()","title":"Polymorphisme"},{"location":"poo/seance-2/polymorphisme/#le-polymorphisme-en-python","text":"Le polymorphisme est l'un des principes fondamentaux de la programmation orient\u00e9e objet (POO) qui permet \u00e0 des objets de diff\u00e9rentes classes d'\u00eatre trait\u00e9s de mani\u00e8re uniforme. Cela signifie que vous pouvez utiliser des m\u00e9thodes ou des op\u00e9rateurs sur ces objets sans vous soucier de leur type sp\u00e9cifique. En Python, le polymorphisme est largement pris en charge gr\u00e2ce \u00e0 la flexibilit\u00e9 du langage.","title":"Le Polymorphisme en Python"},{"location":"poo/seance-2/polymorphisme/#comprendre-le-polymorphisme","text":"Le polymorphisme peut \u00eatre divis\u00e9 en deux types principaux : le polymorphisme de m\u00e9thode et le polymorphisme d'op\u00e9rateur.","title":"Comprendre le Polymorphisme"},{"location":"poo/seance-2/polymorphisme/#polymorphisme-de-methode","text":"Le polymorphisme de m\u00e9thode vous permet d'appeler une m\u00e9thode sur un objet, et la m\u00e9thode ex\u00e9cut\u00e9e d\u00e9pend du type de cet objet . Par exemple, supposons que nous ayons deux classes, Chien et Chat , chacune ayant une m\u00e9thode crier : class Chien: def crier(self): return \"Woof!\" class Chat: def crier(self): return \"Miaou!\" Maintenant, nous pouvons cr\u00e9er des objets de ces classes et appeler la m\u00e9thode crier : chien = Chien() chat = Chat() animaux = [chien, chat] for animal in animaux: print(animal.crier()) Lorsque nous appelons crier sur chaque objet, la m\u00e9thode appropri\u00e9e est appel\u00e9e en fonction du type de l'objet.","title":"Polymorphisme de M\u00e9thode"},{"location":"poo/seance-2/polymorphisme/#polymorphisme-doperateur","text":"Le polymorphisme d'op\u00e9rateur permet d'utiliser des op\u00e9rateurs sur des objets de diff\u00e9rentes classes. Par exemple, vous pouvez utiliser l'op\u00e9rateur + pour concat\u00e9ner des cha\u00eenes de caract\u00e8res, mais aussi pour ajouter des nombres : a = 5 b = 10 resultat = a + b print(resultat) # Affiche 15 chaine1 = \"Hello, \" chaine2 = \"world!\" resultat = chaine1 + chaine2 print(resultat) # Affiche \"Hello, world!\" Python permet d'utiliser de nombreux op\u00e9rateurs de cette mani\u00e8re, tant que les classes d\u00e9finissent les m\u00e9thodes sp\u00e9ciales appropri\u00e9es, comme __add__ , __sub__ , etc.","title":"Polymorphisme d'Op\u00e9rateur"},{"location":"poo/seance-2/polymorphisme/#avantages-du-polymorphisme","text":"Le polymorphisme pr\u00e9sente plusieurs avantages : Flexibilit\u00e9 : Vous pouvez traiter diff\u00e9rents objets de mani\u00e8re uniforme, ce qui simplifie le code. Exemple : class Animal: def __init__(self, nom): self.nom = nom def faire_crier(self): pass class Chien(Animal): def faire_crier(self): return \"Woof!\" class Chat(Animal): def faire_crier(self): return \"Miaou!\" # Utilisation de la flexibilit\u00e9 du polymorphisme def faire_crier_et_afficher(animal): print(\"{} fait {}\".format(animal.nom, animal.faire_crier())) animaux = [Chien(\"Rex\"), Chat(\"Whiskers\")] for animal in animaux: faire_crier_et_afficher(animal) Dans cet exemple, nous utilisons le polymorphisme pour appeler la m\u00e9thode faire_crier sur des objets de diff\u00e9rentes classes, ce qui permet \u00e0 chaque animal de faire le bruit appropri\u00e9. R\u00e9utilisation du Code : Vous pouvez r\u00e9utiliser des m\u00e9thodes ou des op\u00e9rateurs sur des objets de diff\u00e9rentes classes. Exemple : class Forme: def aire(self): pass class Cercle(Forme): def __init__(self, rayon): self.rayon = rayon def aire(self): return 3.14159265359 * self.rayon * self.rayon class Rectangle(Forme): def __init(self, longueur, largeur): self.longueur = longueur self.largeur = largeur def aire(self): return self.longueur * self.largeur # Utilisation de la r\u00e9utilisation du code via le polymorphisme cercle = Cercle(5) rectangle = Rectangle(4, 6) formes = [cercle, rectangle] for forme in formes: print(f\"L'aire de la forme est {forme.*aire()*}\") Extension Facile : Vous pouvez \u00e9tendre le polymorphisme pour prendre en charge de nouvelles classes sans modifier le code existant. Exemple : # Nouvelle classe Triangle class Triangle(Forme): def __init__(self, base, hauteur): self.base = base self.hauteur = hauteur def aire(self): return 0.5 * self.base * self.hauteur triangle = Triangle(3, 4) # Sans modifier le code existant, nous pouvons ajouter un triangle \u00e0 la liste des formes formes.append(triangle) for forme in formes: print(f\"L'aire de la forme est {forme.*aire()*}\")","title":"Avantages du Polymorphisme"},{"location":"poo/seance-2/polymorphisme/#exercices","text":"Exercice 1 : Calcul d'aire de formes g\u00e9om\u00e9triques \u00c9crivez une classe de base appel\u00e9e Forme avec une m\u00e9thode aire() . Ensuite, cr\u00e9ez trois sous-classes de Forme : Cercle , Rectangle , et Triangle , chacune avec sa propre impl\u00e9mentation de la m\u00e9thode aire() . Enfin, cr\u00e9ez une liste de formes contenant des instances de ces trois sous-classes. Calculez et affichez l'aire de chaque forme \u00e0 partir de la liste. Solution class Forme(): def aire(self): pass class Cercle(Forme): def __init__(self, rayon): self.rayon = rayon def aire(self): return 3.14159265359 * self.rayon * self.rayon class Rectangle(Forme): def __init__(self, longueur, largeur): self.longueur = longueur self.largeur = largeur def aire(self): return self.longueur * self.largeur class Triangle(Forme): def __init__(self, base, hauteur): self.base = base self.hauteur = hauteur def aire(self): return 0.5 * self.base * self.hauteur # Cr\u00e9ation d'une liste de formes formes = [Cercle(5), Rectangle(4, 6), Triangle(3, 4)] # Calcul et affichage de l'aire de chaque forme for forme in formes: print(\"L'aire de la forme est \"+str(forme.aire())) # R\u00e9sultat attendu : # L'aire du cercle est 78.53981633974483 # L'aire du rectangle est 24 # L'aire du triangle est 6.0 Exercice 2 : Polymorphisme avec des v\u00e9hicules Cr\u00e9ez une classe de base appel\u00e9e Vehicule avec une m\u00e9thode afficher_info qui affiche des informations de base sur le v\u00e9hicule, telles que le nom du v\u00e9hicule. Cr\u00e9ez trois sous-classes de Vehicule : Voiture , Moto , et Velo , chacune avec son propre constructeur et des informations sp\u00e9cifiques (par exemple, le nombre de roues pour chaque type de v\u00e9hicule). Instanciez plusieurs v\u00e9hicules de chaque type (voiture, moto, v\u00e9lo) et stockez-les dans une liste. Utilisez le polymorphisme pour appeler la m\u00e9thode afficher_info pour chaque v\u00e9hicule de la liste, affichant ainsi des informations sp\u00e9cifiques \u00e0 chaque type de v\u00e9hicule. Solution class Vehicule: def __init__(self, nom): self.nom = nom def afficher_info(self): print(\"V\u00e9hicule : {}\".format(self.nom)) class Voiture(Vehicule): def __init__(self, nom, roues): super().__init__(nom) self.roues = roues def afficher_info(self): print(\"Voiture : {}, Roues : {}\".format(self.nom, self.roues)) class Moto(Vehicule): def __init__(self, nom, roues): super().__init__(nom) self.roues = roues def afficher_info(self): print(\"Moto : {}, Roues : {}\".format(self.nom, self.roues)) class Velo(Vehicule): def __init__(self, nom, roues): super().__init__(nom) self.roues = roues def afficher_info(self): print(\"V\u00e9lo : {}, Roues : {}\".format(self.nom, self.roues)) # Cr\u00e9ation d'une liste de v\u00e9hicules vehicules = [Voiture(\"Sedan\", 4), Moto(\"Sportive\", 2), Velo(\"Montagne\", 2), Voiture(\"Compacte\", 4)] # Utilisation du polymorphisme pour afficher les informations de chaque v\u00e9hicule for vehicule in vehicules: vehicule.afficher_info()","title":"Exercices"},{"location":"poo/seance-2/surcharge_methodes/","text":"Surcharge de M\u00e9thodes en Python La surcharge de m\u00e9thodes est un concept cl\u00e9 de la programmation orient\u00e9e objet (POO) qui permet \u00e0 une classe de d\u00e9finir plusieurs m\u00e9thodes avec le m\u00eame nom, mais des param\u00e8tres diff\u00e9rents . En Python, vous pouvez surcharger des m\u00e9thodes pour personnaliser le comportement en fonction des arguments pass\u00e9s. Signature de M\u00e9thode La surcharge de m\u00e9thodes repose sur la signature de m\u00e9thode, qui comprend le nom de la m\u00e9thode et le type, l'ordre ou le nombre de ses param\u00e8tres. Deux m\u00e9thodes doivent avoir une signature diff\u00e9rente pour \u00eatre correctement surcharg\u00e9es. def nom_de_methode(parametre1, parametre2, ...): # Signature de la m\u00e9thode # Corps de la m\u00e9thode Surcharge de M\u00e9thodes en Python En Python, vous pouvez surcharger des m\u00e9thodes en d\u00e9finissant plusieurs m\u00e9thodes avec le m\u00eame nom dans une classe, mais des signatures de param\u00e8tres diff\u00e9rentes. Lorsqu'une m\u00e9thode est appel\u00e9e, Python d\u00e9termine quelle version de la m\u00e9thode ex\u00e9cuter en fonction des arguments pass\u00e9s. class MaClasse: def surcharge(self, parametre1): # Version avec un seul param\u00e8tre # Code ici def surcharge(self, parametre1, parametre2): # Version avec deux param\u00e8tres # Code ici # Utilisation de la surcharge de m\u00e9thodes objet = MaClasse() objet.surcharge(arg1) # Ex\u00e9cute la premi\u00e8re version objet.surcharge(arg1, arg2) # Ex\u00e9cute la deuxi\u00e8me version Exemple de Surcharge de M\u00e9thodes class Calculatrice: def addition(self, a, b): return a + b def addition(self, a, b, c): return a + b + c # Utilisation de la surcharge de m\u00e9thodes calc = Calculatrice() resultat1 = calc.addition(2, 3) # Ex\u00e9cute la premi\u00e8re version resultat2 = calc.addition(2, 3, 4) # Ex\u00e9cute la deuxi\u00e8me version print(resultat1) # Affiche 5 print(resultat2) # Affiche 9 Avantages de la Surcharge de M\u00e9thodes Personnalisation du Comportement : Vous pouvez adapter le comportement d'une m\u00e9thode en fonction du nombre ou du type de param\u00e8tres pass\u00e9s. Lisibilit\u00e9 du Code : La surcharge de m\u00e9thodes permet d'avoir des noms de m\u00e9thodes coh\u00e9rents pour des op\u00e9rations similaires. R\u00e9utilisation du Code : Vous pouvez r\u00e9utiliser le nom de m\u00e9thode pour effectuer des op\u00e9rations similaires avec des param\u00e8tres diff\u00e9rents. Exercices Corrig\u00e9s Exercice 1 Cr\u00e9ez une classe Rectangle avec une m\u00e9thode aire() qui accepte deux param\u00e8tres, longueur et largeur , et calcule l'aire du rectangle. Ensuite, surchargez la m\u00e9thode aire() pour qu'elle accepte trois param\u00e8tres, longueur, largeur et hauteur, et calcule le volume d'un prisme rectangulaire. class Rectangle: def aire(self, longueur, largeur): return longueur * largeur def aire(self, longueur, largeur, hauteur): return longueur * largeur * hauteur # Utilisation de la surcharge de m\u00e9thodes r = Rectangle() aire2D = r.aire(5, 3) aire3D = r.aire(5, 3, 2) print(\"Aire 2D :\", aire2D) # Affiche \"Aire 2D : 15\" print(\"Aire 3D :\", aire3D) # Affiche \"Aire 3D : 30\" Exercice 2 Cr\u00e9ez une classe Cercle avec une m\u00e9thode aire() qui accepte un param\u00e8tre rayon et calcule l'aire du cercle. Surchargez la m\u00e9thode aire() pour qu'elle accepte un param\u00e8tre diametre et calcule l'aire du cercle en utilisant le diam\u00e8tre. class Cercle: def aire(self, rayon): return 3.14159 * rayon * rayon def aire(self, diametre): rayon = diametre / 2 return 3.14159 * rayon * rayon # Utilisation de la surcharge de m\u00e9thodes c = Cercle() aire1 = c.aire(5) aire2 = c.aire(10) print(\"Aire 1 :\", aire1) # Affiche \"Aire 1 : 78.53975\" print(\"Aire 2 :\", aire2) # Affiche \"Aire 2 : 78.53975\"","title":"Programmation Orient\u00e9e Objet (POO) en Python"},{"location":"poo/seance-2/surcharge_methodes/#surcharge-de-methodes-en-python","text":"La surcharge de m\u00e9thodes est un concept cl\u00e9 de la programmation orient\u00e9e objet (POO) qui permet \u00e0 une classe de d\u00e9finir plusieurs m\u00e9thodes avec le m\u00eame nom, mais des param\u00e8tres diff\u00e9rents . En Python, vous pouvez surcharger des m\u00e9thodes pour personnaliser le comportement en fonction des arguments pass\u00e9s.","title":"Surcharge de M\u00e9thodes en Python"},{"location":"poo/seance-2/surcharge_methodes/#signature-de-methode","text":"La surcharge de m\u00e9thodes repose sur la signature de m\u00e9thode, qui comprend le nom de la m\u00e9thode et le type, l'ordre ou le nombre de ses param\u00e8tres. Deux m\u00e9thodes doivent avoir une signature diff\u00e9rente pour \u00eatre correctement surcharg\u00e9es. def nom_de_methode(parametre1, parametre2, ...): # Signature de la m\u00e9thode # Corps de la m\u00e9thode","title":"Signature de M\u00e9thode"},{"location":"poo/seance-2/surcharge_methodes/#surcharge-de-methodes-en-python_1","text":"En Python, vous pouvez surcharger des m\u00e9thodes en d\u00e9finissant plusieurs m\u00e9thodes avec le m\u00eame nom dans une classe, mais des signatures de param\u00e8tres diff\u00e9rentes. Lorsqu'une m\u00e9thode est appel\u00e9e, Python d\u00e9termine quelle version de la m\u00e9thode ex\u00e9cuter en fonction des arguments pass\u00e9s. class MaClasse: def surcharge(self, parametre1): # Version avec un seul param\u00e8tre # Code ici def surcharge(self, parametre1, parametre2): # Version avec deux param\u00e8tres # Code ici # Utilisation de la surcharge de m\u00e9thodes objet = MaClasse() objet.surcharge(arg1) # Ex\u00e9cute la premi\u00e8re version objet.surcharge(arg1, arg2) # Ex\u00e9cute la deuxi\u00e8me version Exemple de Surcharge de M\u00e9thodes class Calculatrice: def addition(self, a, b): return a + b def addition(self, a, b, c): return a + b + c # Utilisation de la surcharge de m\u00e9thodes calc = Calculatrice() resultat1 = calc.addition(2, 3) # Ex\u00e9cute la premi\u00e8re version resultat2 = calc.addition(2, 3, 4) # Ex\u00e9cute la deuxi\u00e8me version print(resultat1) # Affiche 5 print(resultat2) # Affiche 9","title":"Surcharge de M\u00e9thodes en Python"},{"location":"poo/seance-2/surcharge_methodes/#avantages-de-la-surcharge-de-methodes","text":"Personnalisation du Comportement : Vous pouvez adapter le comportement d'une m\u00e9thode en fonction du nombre ou du type de param\u00e8tres pass\u00e9s. Lisibilit\u00e9 du Code : La surcharge de m\u00e9thodes permet d'avoir des noms de m\u00e9thodes coh\u00e9rents pour des op\u00e9rations similaires. R\u00e9utilisation du Code : Vous pouvez r\u00e9utiliser le nom de m\u00e9thode pour effectuer des op\u00e9rations similaires avec des param\u00e8tres diff\u00e9rents.","title":"Avantages de la Surcharge de M\u00e9thodes"},{"location":"poo/seance-2/surcharge_methodes/#exercices-corriges","text":"Exercice 1 Cr\u00e9ez une classe Rectangle avec une m\u00e9thode aire() qui accepte deux param\u00e8tres, longueur et largeur , et calcule l'aire du rectangle. Ensuite, surchargez la m\u00e9thode aire() pour qu'elle accepte trois param\u00e8tres, longueur, largeur et hauteur, et calcule le volume d'un prisme rectangulaire. class Rectangle: def aire(self, longueur, largeur): return longueur * largeur def aire(self, longueur, largeur, hauteur): return longueur * largeur * hauteur # Utilisation de la surcharge de m\u00e9thodes r = Rectangle() aire2D = r.aire(5, 3) aire3D = r.aire(5, 3, 2) print(\"Aire 2D :\", aire2D) # Affiche \"Aire 2D : 15\" print(\"Aire 3D :\", aire3D) # Affiche \"Aire 3D : 30\" Exercice 2 Cr\u00e9ez une classe Cercle avec une m\u00e9thode aire() qui accepte un param\u00e8tre rayon et calcule l'aire du cercle. Surchargez la m\u00e9thode aire() pour qu'elle accepte un param\u00e8tre diametre et calcule l'aire du cercle en utilisant le diam\u00e8tre. class Cercle: def aire(self, rayon): return 3.14159 * rayon * rayon def aire(self, diametre): rayon = diametre / 2 return 3.14159 * rayon * rayon # Utilisation de la surcharge de m\u00e9thodes c = Cercle() aire1 = c.aire(5) aire2 = c.aire(10) print(\"Aire 1 :\", aire1) # Affiche \"Aire 1 : 78.53975\" print(\"Aire 2 :\", aire2) # Affiche \"Aire 2 : 78.53975\"","title":"Exercices Corrig\u00e9s"},{"location":"poo/seance-3/class-object/","text":"La Classe Object en Python et ses M\u00e9thodes Sp\u00e9ciales La classe object est la classe de base de toutes les classes en Python. Elle est implicitement h\u00e9rit\u00e9e par toutes les classes d\u00e9finies dans Python. La classe object est au sommet de la hi\u00e9rarchie de l'h\u00e9ritage des classes, ce qui signifie que toutes les autres classes, m\u00eame si elles n'en h\u00e9ritent pas explicitement, sont en fin de compte des sous-classes de la classe object. La classe object d\u00e9finit certaines m\u00e9thodes sp\u00e9ciales et attributs pr\u00e9d\u00e9finis qui sont h\u00e9rit\u00e9s par toutes les autres classes. Les principales m\u00e9thodes sp\u00e9ciales d\u00e9finies dans la classe object incluent : __init__(self) : Cette m\u00e9thode est le constructeur de base de tous les objets en Python. Elle est appel\u00e9e lors de la cr\u00e9ation d'une instance d'une classe pour effectuer l'initialisation. __str__(self) : Cette m\u00e9thode est utilis\u00e9e pour repr\u00e9senter l'objet sous forme de cha\u00eene de caract\u00e8res lorsqu'il est converti en une cha\u00eene (par exemple, avec la fonction str() ou lors de l'impression avec la fonction print() ). __repr__(self) : Cette m\u00e9thode est utilis\u00e9e pour obtenir une repr\u00e9sentation \"formelle\" de l'objet, g\u00e9n\u00e9ralement sous forme de cha\u00eene de caract\u00e8res. Elle est utilis\u00e9e par la fonction repr() . __eq__(self, other) : Cette m\u00e9thode est utilis\u00e9e pour d\u00e9finir l'\u00e9galit\u00e9 entre deux objets de la classe. Elle est appel\u00e9e lorsque l'on compare des objets avec l'op\u00e9rateur == . Pour conna\u00eetre les m\u00e9thodes et les attributs pr\u00e9d\u00e9finis de la classe object, vous pouvez utiliser la fonction dir() en Python. Voici comment vous pouvez l'utiliser : print(dir(object)) Cela affichera une liste de toutes les m\u00e9thodes et attributs disponibles dans la classe object. Les m\u00e9thodes sp\u00e9ciales de la classe object peuvent \u00eatre surcharg\u00e9es (red\u00e9finies) dans les classes d\u00e9riv\u00e9es pour personnaliser le comportement des objets de ces classes. La documentation officielle de Python contient des informations utiles sur la classe object . Le code source la classe object cod\u00e9 en langage C cpython/Objects/object.c at main \u00b7 python/cpython \u00b7 GitHub La classe object elle-m\u00eame est con\u00e7ue pour \u00eatre une classe de base minimale, et son but principal est de fournir l'h\u00e9ritage de base et les m\u00e9thodes sp\u00e9ciales communes \u00e0 toutes les autres classes en Python. L'utilisation la plus courante de la classe object est implicitement lors de la d\u00e9finition de classes d\u00e9riv\u00e9es. Toutes les classes en Python h\u00e9ritent automatiquement de la classe object, m\u00eame si ce n'est pas sp\u00e9cifiquement d\u00e9clar\u00e9. Par exemple : class MaClasse: pass # MaClasse h\u00e9rite de la classe object my_instance = MaClasse() Dans cet exemple, MaClasse h\u00e9rite de la classe object , ce qui signifie que my_instance est une instance de MaClasse , mais elle h\u00e9rite \u00e9galement des fonctionnalit\u00e9s de base de la classe object .","title":"Classe Object"},{"location":"poo/seance-3/class-object/#la-classe-object-en-python-et-ses-methodes-speciales","text":"La classe object est la classe de base de toutes les classes en Python. Elle est implicitement h\u00e9rit\u00e9e par toutes les classes d\u00e9finies dans Python. La classe object est au sommet de la hi\u00e9rarchie de l'h\u00e9ritage des classes, ce qui signifie que toutes les autres classes, m\u00eame si elles n'en h\u00e9ritent pas explicitement, sont en fin de compte des sous-classes de la classe object. La classe object d\u00e9finit certaines m\u00e9thodes sp\u00e9ciales et attributs pr\u00e9d\u00e9finis qui sont h\u00e9rit\u00e9s par toutes les autres classes. Les principales m\u00e9thodes sp\u00e9ciales d\u00e9finies dans la classe object incluent : __init__(self) : Cette m\u00e9thode est le constructeur de base de tous les objets en Python. Elle est appel\u00e9e lors de la cr\u00e9ation d'une instance d'une classe pour effectuer l'initialisation. __str__(self) : Cette m\u00e9thode est utilis\u00e9e pour repr\u00e9senter l'objet sous forme de cha\u00eene de caract\u00e8res lorsqu'il est converti en une cha\u00eene (par exemple, avec la fonction str() ou lors de l'impression avec la fonction print() ). __repr__(self) : Cette m\u00e9thode est utilis\u00e9e pour obtenir une repr\u00e9sentation \"formelle\" de l'objet, g\u00e9n\u00e9ralement sous forme de cha\u00eene de caract\u00e8res. Elle est utilis\u00e9e par la fonction repr() . __eq__(self, other) : Cette m\u00e9thode est utilis\u00e9e pour d\u00e9finir l'\u00e9galit\u00e9 entre deux objets de la classe. Elle est appel\u00e9e lorsque l'on compare des objets avec l'op\u00e9rateur == . Pour conna\u00eetre les m\u00e9thodes et les attributs pr\u00e9d\u00e9finis de la classe object, vous pouvez utiliser la fonction dir() en Python. Voici comment vous pouvez l'utiliser : print(dir(object)) Cela affichera une liste de toutes les m\u00e9thodes et attributs disponibles dans la classe object. Les m\u00e9thodes sp\u00e9ciales de la classe object peuvent \u00eatre surcharg\u00e9es (red\u00e9finies) dans les classes d\u00e9riv\u00e9es pour personnaliser le comportement des objets de ces classes. La documentation officielle de Python contient des informations utiles sur la classe object . Le code source la classe object cod\u00e9 en langage C cpython/Objects/object.c at main \u00b7 python/cpython \u00b7 GitHub La classe object elle-m\u00eame est con\u00e7ue pour \u00eatre une classe de base minimale, et son but principal est de fournir l'h\u00e9ritage de base et les m\u00e9thodes sp\u00e9ciales communes \u00e0 toutes les autres classes en Python. L'utilisation la plus courante de la classe object est implicitement lors de la d\u00e9finition de classes d\u00e9riv\u00e9es. Toutes les classes en Python h\u00e9ritent automatiquement de la classe object, m\u00eame si ce n'est pas sp\u00e9cifiquement d\u00e9clar\u00e9. Par exemple : class MaClasse: pass # MaClasse h\u00e9rite de la classe object my_instance = MaClasse() Dans cet exemple, MaClasse h\u00e9rite de la classe object , ce qui signifie que my_instance est une instance de MaClasse , mais elle h\u00e9rite \u00e9galement des fonctionnalit\u00e9s de base de la classe object .","title":"La Classe Object en Python et ses M\u00e9thodes Sp\u00e9ciales"},{"location":"poo/seance-3/encapsulation/","text":"L'Encapsulation en Python L'encapsulation est l'un des concepts cl\u00e9s de la programmation orient\u00e9e objet (POO). Il s'agit du m\u00e9canisme qui permet de restreindre l'acc\u00e8s aux d\u00e9tails internes d'une classe tout en exposant une interface publique pour interagir avec cette classe. En Python, l'encapsulation repose principalement sur la convention plut\u00f4t que sur la stricte application de restrictions d'acc\u00e8s. Attributs et M\u00e9thodes Attributs Les attributs sont des variables associ\u00e9es \u00e0 une classe. Ils peuvent \u00eatre utilis\u00e9s pour stocker des donn\u00e9es sp\u00e9cifiques \u00e0 cette classe. En Python, il y a trois types d'attributs : Attributs Publics : Ils sont accessibles directement depuis n'importe o\u00f9. Attributs Prot\u00e9g\u00e9s : Ils commencent par un seul soulign\u00e9 (par exemple, _attribut ). Bien qu'ils soient accessibles depuis l'ext\u00e9rieur de la classe, ils sont consid\u00e9r\u00e9s comme des attributs \"prot\u00e9g\u00e9s\", et il est recommand\u00e9 de ne pas y acc\u00e9der directement. Attributs Priv\u00e9s : Ils commencent par deux soulign\u00e9s (par exemple, __attribut ). Ils sont destin\u00e9s \u00e0 \u00eatre priv\u00e9s et ne devraient pas \u00eatre accessibles depuis l'ext\u00e9rieur de la classe. M\u00e9thodes Les m\u00e9thodes sont des fonctions associ\u00e9es \u00e0 une classe. Elles d\u00e9finissent le comportement de la classe. De la m\u00eame mani\u00e8re, il existe trois types de m\u00e9thodes : M\u00e9thodes Publiques : Elles sont accessibles depuis n'importe o\u00f9. M\u00e9thodes Prot\u00e9g\u00e9es : Elles commencent par un seul soulign\u00e9 (par exemple, _methode ). Bien qu'elles soient accessibles depuis l'ext\u00e9rieur de la classe, elles sont consid\u00e9r\u00e9es comme des m\u00e9thodes \"prot\u00e9g\u00e9es\". M\u00e9thodes Priv\u00e9es : Elles commencent par deux soulign\u00e9s (par exemple, __methode ). Elles sont destin\u00e9es \u00e0 \u00eatre priv\u00e9es et ne devraient pas \u00eatre accessibles depuis l'ext\u00e9rieur de la classe. Encapsulation en Python En Python, l'encapsulation repose sur des conventions plut\u00f4t que sur des m\u00e9canismes stricts de restriction d'acc\u00e8s. Voici quelques pratiques courantes d'encapsulation en Python : Attributs Prot\u00e9g\u00e9s : Utilisez des attributs commen\u00e7ant par un seul soulign\u00e9 (par exemple, _attribut) pour indiquer qu'ils sont destin\u00e9s \u00e0 \u00eatre \"prot\u00e9g\u00e9s\", mais laissez-les accessibles depuis l'ext\u00e9rieur de la classe. Attributs Priv\u00e9s : Utilisez des attributs commen\u00e7ant par deux soulign\u00e9s (par exemple, __attribut) pour indiquer qu'ils sont priv\u00e9s. Cela les rend plus difficiles \u00e0 acc\u00e9der depuis l'ext\u00e9rieur de la classe, mais ils ne sont pas totalement inaccessibles. M\u00e9thodes Priv\u00e9es : Les m\u00e9thodes priv\u00e9es commen\u00e7ant par deux soulign\u00e9s (par exemple, __methode) ne sont pas accessibles directement depuis l'ext\u00e9rieur de la classe. Cependant, elles peuvent \u00eatre appel\u00e9es depuis d'autres m\u00e9thodes de la classe. Exemple d'Encapsulation class CompteBancaire: def __init__(self, solde): self.__solde = solde # Attribut priv\u00e9 def deposer(self, montant): self.__solde += montant def retirer(self, montant): if self.__solde >= montant: self.__solde -= montant else: print(\"Fonds insuffisants\") # M\u00e9thode d'acc\u00e8s (getter) pour l'attribut priv\u00e9 def solde(self): return self.__solde def __str__(self): return \"Solde actuel :\"+ str(self.__solde) # Exemple d'utilisation compte = CompteBancaire(1000) compte.deposer(500) compte.retirer(200) print(compte) Dans cet exemple, la classe CompteBancaire utilise l'encapsulation pour masquer l'attribut priv\u00e9 __solde et expose une m\u00e9thode d'acc\u00e8s ( solde ) pour obtenir la valeur de cet attribut. L'encapsulation permet de contr\u00f4ler l'acc\u00e8s aux donn\u00e9es internes de la classe et fournit une interface publique pour interagir avec l'objet compte.","title":"Encapsulation"},{"location":"poo/seance-3/encapsulation/#lencapsulation-en-python","text":"L'encapsulation est l'un des concepts cl\u00e9s de la programmation orient\u00e9e objet (POO). Il s'agit du m\u00e9canisme qui permet de restreindre l'acc\u00e8s aux d\u00e9tails internes d'une classe tout en exposant une interface publique pour interagir avec cette classe. En Python, l'encapsulation repose principalement sur la convention plut\u00f4t que sur la stricte application de restrictions d'acc\u00e8s.","title":"L'Encapsulation en Python"},{"location":"poo/seance-3/encapsulation/#attributs-et-methodes","text":"","title":"Attributs et M\u00e9thodes"},{"location":"poo/seance-3/encapsulation/#attributs","text":"Les attributs sont des variables associ\u00e9es \u00e0 une classe. Ils peuvent \u00eatre utilis\u00e9s pour stocker des donn\u00e9es sp\u00e9cifiques \u00e0 cette classe. En Python, il y a trois types d'attributs : Attributs Publics : Ils sont accessibles directement depuis n'importe o\u00f9. Attributs Prot\u00e9g\u00e9s : Ils commencent par un seul soulign\u00e9 (par exemple, _attribut ). Bien qu'ils soient accessibles depuis l'ext\u00e9rieur de la classe, ils sont consid\u00e9r\u00e9s comme des attributs \"prot\u00e9g\u00e9s\", et il est recommand\u00e9 de ne pas y acc\u00e9der directement. Attributs Priv\u00e9s : Ils commencent par deux soulign\u00e9s (par exemple, __attribut ). Ils sont destin\u00e9s \u00e0 \u00eatre priv\u00e9s et ne devraient pas \u00eatre accessibles depuis l'ext\u00e9rieur de la classe.","title":"Attributs"},{"location":"poo/seance-3/encapsulation/#methodes","text":"Les m\u00e9thodes sont des fonctions associ\u00e9es \u00e0 une classe. Elles d\u00e9finissent le comportement de la classe. De la m\u00eame mani\u00e8re, il existe trois types de m\u00e9thodes : M\u00e9thodes Publiques : Elles sont accessibles depuis n'importe o\u00f9. M\u00e9thodes Prot\u00e9g\u00e9es : Elles commencent par un seul soulign\u00e9 (par exemple, _methode ). Bien qu'elles soient accessibles depuis l'ext\u00e9rieur de la classe, elles sont consid\u00e9r\u00e9es comme des m\u00e9thodes \"prot\u00e9g\u00e9es\". M\u00e9thodes Priv\u00e9es : Elles commencent par deux soulign\u00e9s (par exemple, __methode ). Elles sont destin\u00e9es \u00e0 \u00eatre priv\u00e9es et ne devraient pas \u00eatre accessibles depuis l'ext\u00e9rieur de la classe.","title":"M\u00e9thodes"},{"location":"poo/seance-3/encapsulation/#encapsulation-en-python","text":"En Python, l'encapsulation repose sur des conventions plut\u00f4t que sur des m\u00e9canismes stricts de restriction d'acc\u00e8s. Voici quelques pratiques courantes d'encapsulation en Python : Attributs Prot\u00e9g\u00e9s : Utilisez des attributs commen\u00e7ant par un seul soulign\u00e9 (par exemple, _attribut) pour indiquer qu'ils sont destin\u00e9s \u00e0 \u00eatre \"prot\u00e9g\u00e9s\", mais laissez-les accessibles depuis l'ext\u00e9rieur de la classe. Attributs Priv\u00e9s : Utilisez des attributs commen\u00e7ant par deux soulign\u00e9s (par exemple, __attribut) pour indiquer qu'ils sont priv\u00e9s. Cela les rend plus difficiles \u00e0 acc\u00e9der depuis l'ext\u00e9rieur de la classe, mais ils ne sont pas totalement inaccessibles. M\u00e9thodes Priv\u00e9es : Les m\u00e9thodes priv\u00e9es commen\u00e7ant par deux soulign\u00e9s (par exemple, __methode) ne sont pas accessibles directement depuis l'ext\u00e9rieur de la classe. Cependant, elles peuvent \u00eatre appel\u00e9es depuis d'autres m\u00e9thodes de la classe.","title":"Encapsulation en Python"},{"location":"poo/seance-3/encapsulation/#exemple-dencapsulation","text":"class CompteBancaire: def __init__(self, solde): self.__solde = solde # Attribut priv\u00e9 def deposer(self, montant): self.__solde += montant def retirer(self, montant): if self.__solde >= montant: self.__solde -= montant else: print(\"Fonds insuffisants\") # M\u00e9thode d'acc\u00e8s (getter) pour l'attribut priv\u00e9 def solde(self): return self.__solde def __str__(self): return \"Solde actuel :\"+ str(self.__solde) # Exemple d'utilisation compte = CompteBancaire(1000) compte.deposer(500) compte.retirer(200) print(compte) Dans cet exemple, la classe CompteBancaire utilise l'encapsulation pour masquer l'attribut priv\u00e9 __solde et expose une m\u00e9thode d'acc\u00e8s ( solde ) pour obtenir la valeur de cet attribut. L'encapsulation permet de contr\u00f4ler l'acc\u00e8s aux donn\u00e9es internes de la classe et fournit une interface publique pour interagir avec l'objet compte.","title":"Exemple d'Encapsulation"},{"location":"poo/seance-3/methodes-speciales/","text":"Les M\u00e9thodes Sp\u00e9ciales en Python Les m\u00e9thodes sp\u00e9ciales , ou m\u00e9thodes magiques , sont des m\u00e9thodes pr\u00e9d\u00e9finies en Python avec un nom qui commence et se termine par un double soulign\u00e9 (par exemple, __init__ , __str__ , __add__ ). Elles sont utilis\u00e9es pour surcharger le comportement de base des op\u00e9rations et des fonctions associ\u00e9es aux objets. M\u00e9thode __init__ La m\u00e9thode __init__(self) est le constructeur de base de tous les objets en Python. Elle est appel\u00e9e lors de la cr\u00e9ation d'une instance d'une classe pour effectuer l'initialisation. Exemple d'utilisation : class Personne: def __init__(self, nom, age): self.nom = nom self.age = age M\u00e9thodes __str__ et __repr__ La m\u00e9thode __str__(self) est utilis\u00e9e pour repr\u00e9senter l'objet sous forme de cha\u00eene de caract\u00e8res lorsqu'il est converti en une cha\u00eene (par exemple, avec la fonction str() ou lors de l'impression avec print() ). La m\u00e9thode __repr__(self) est utilis\u00e9e pour obtenir une repr\u00e9sentation \"formelle\" de l'objet, g\u00e9n\u00e9ralement utilis\u00e9e pour le d\u00e9bogage par la fonction repr() . Exemple d'utilisation : class Personne: def __init__(self, nom, age): self.nom = nom self.age = age def __str__(self): return self.nom + \" \"+ self.age +\"ans\" def __repr__(self): return \"Personne({}, {})\".format(self.nom,self.age) Les m\u00e9thodes __str__ et __repr__ sont utilis\u00e9es pour la repr\u00e9sentation textuelle d'un objet. Si elles ne sont pas surcharg\u00e9es dans une classe, Python utilise les impl\u00e9mentations par d\u00e9faut de la classe object pour afficher l'objet. M\u00e9thodes d'Op\u00e9ration Math\u00e9matique Les m\u00e9thodes sp\u00e9ciales d'op\u00e9ration math\u00e9matique permettent de personnaliser le comportement des op\u00e9rateurs math\u00e9matiques tels que l'addition __add__ , la soustraction __sub__ , la multiplication __mul__ , etc. Exemple d'utilisation : class Point: def __init__(self, x, y): self.x = x self.y = y def __add__(self, other): return Point(self.x + other.x, self.y + other.y) M\u00e9thode __eq__ La m\u00e9thode __eq__(self,other) permet de personnaliser la comparaison d'\u00e9galit\u00e9 entre deux objets de la classe.. Exemple d'utilisation : class Personne: def __init__(self, nom, age): self.nom = nom self.age = age def __eq__(self, other): return self.nom == other.nom and self.age == other.age M\u00e9thode __len__ La m\u00e9thode __len__ permet de personnaliser la mani\u00e8re dont la taille d'un objet est calcul\u00e9e. Exemple d'utilisation : Pour une classe de biblioth\u00e8que, vous pouvez surcharger la m\u00e9thode __len__ pour renvoyer le nombre total de livres disponibles dans cette biblioth\u00e8que. class Livre: def __init__(self, titre, auteur): self.titre = titre self.auteur = auteur class Bibliotheque: def __init__(self): self.livres = [] def ajouter_livre(self, livre): self.livres.append(livre) def __len__(self): return len(self.livres) # Cr\u00e9ez une instance de la classe Bibliotheque ma_bibliotheque = Bibliotheque() # Ajoutez des livres \u00e0 la biblioth\u00e8que livre1 = Livre(\"L'Alchimiste\", \"Paulo Coelho\") livre2 = Livre(\"1984\", \"George Orwell\") livre3 = Livre(\"Le Petit Prince\", \"Antoine de Saint-Exup\u00e9ry\") ma_bibliotheque.ajouter_livre(livre1) ma_bibliotheque.ajouter_livre(livre2) ma_bibliotheque.ajouter_livre(livre3) # Utilisation de la m\u00e9thode __len__ pour obtenir le nombre de livres dans la biblioth\u00e8que nombre_de_livres = len(ma_bibliotheque) print(\"Nombre de livres dans la biblioth\u00e8que :\", nombre_de_livres) Exercices Cr\u00e9ez une classe Vecteur qui repr\u00e9sente des vecteurs en 2D avec des attributs x et y. La classe doit avoir une m\u00e9thode sp\u00e9ciale __abs__ pour calculer la norme du vecteur. Rappel : La fonction abs() appliqu\u00e9e \u00e0 un vecteur en math\u00e9matiques (en particulier en g\u00e9om\u00e9trie) renvoie la norme du vecteur. La norme d'un vecteur est une mesure de sa longueur, c'est-\u00e0-dire la distance du point de d\u00e9part (origine) au point d'extr\u00e9mit\u00e9 (bout de la fl\u00e8che) du vecteur. Pour un vecteur bidimensionnel (x, y), la formule est la suivante : Norme = \u221a(x^2 + y^2) Pour un vecteur tridimensionnel (x, y, z), la formule est \u00e9tendue comme suit : Norme = \u221a(x^2 + y^2 + z^2) Solution import math class Vecteur: def __init__(self, x, y): self.x = x self.y = y def __abs__(self): return math.sqrt(self.x ** 2 + self.y ** 2) # Exemple d'utilisation v = Vecteur(3, 4) norme = abs(v) print(\"Norme du vecteur :\",norme) Conclusion Les m\u00e9thodes sp\u00e9ciales en Python permettent de personnaliser le comportement des objets de vos classes. Elles facilitent l'interaction avec ces objets et rendent votre code plus lisible et plus propre. En les utilisant correctement, vous pouvez concevoir des classes plus expressives et puissantes.","title":"M\u00e9thodes sp\u00e9ciales"},{"location":"poo/seance-3/methodes-speciales/#les-methodes-speciales-en-python","text":"Les m\u00e9thodes sp\u00e9ciales , ou m\u00e9thodes magiques , sont des m\u00e9thodes pr\u00e9d\u00e9finies en Python avec un nom qui commence et se termine par un double soulign\u00e9 (par exemple, __init__ , __str__ , __add__ ). Elles sont utilis\u00e9es pour surcharger le comportement de base des op\u00e9rations et des fonctions associ\u00e9es aux objets.","title":"Les M\u00e9thodes Sp\u00e9ciales en Python"},{"location":"poo/seance-3/methodes-speciales/#methode-__init__","text":"La m\u00e9thode __init__(self) est le constructeur de base de tous les objets en Python. Elle est appel\u00e9e lors de la cr\u00e9ation d'une instance d'une classe pour effectuer l'initialisation. Exemple d'utilisation : class Personne: def __init__(self, nom, age): self.nom = nom self.age = age","title":"M\u00e9thode __init__"},{"location":"poo/seance-3/methodes-speciales/#methodes-__str__-et-__repr__","text":"La m\u00e9thode __str__(self) est utilis\u00e9e pour repr\u00e9senter l'objet sous forme de cha\u00eene de caract\u00e8res lorsqu'il est converti en une cha\u00eene (par exemple, avec la fonction str() ou lors de l'impression avec print() ). La m\u00e9thode __repr__(self) est utilis\u00e9e pour obtenir une repr\u00e9sentation \"formelle\" de l'objet, g\u00e9n\u00e9ralement utilis\u00e9e pour le d\u00e9bogage par la fonction repr() . Exemple d'utilisation : class Personne: def __init__(self, nom, age): self.nom = nom self.age = age def __str__(self): return self.nom + \" \"+ self.age +\"ans\" def __repr__(self): return \"Personne({}, {})\".format(self.nom,self.age) Les m\u00e9thodes __str__ et __repr__ sont utilis\u00e9es pour la repr\u00e9sentation textuelle d'un objet. Si elles ne sont pas surcharg\u00e9es dans une classe, Python utilise les impl\u00e9mentations par d\u00e9faut de la classe object pour afficher l'objet.","title":"M\u00e9thodes __str__ et __repr__"},{"location":"poo/seance-3/methodes-speciales/#methodes-doperation-mathematique","text":"Les m\u00e9thodes sp\u00e9ciales d'op\u00e9ration math\u00e9matique permettent de personnaliser le comportement des op\u00e9rateurs math\u00e9matiques tels que l'addition __add__ , la soustraction __sub__ , la multiplication __mul__ , etc. Exemple d'utilisation : class Point: def __init__(self, x, y): self.x = x self.y = y def __add__(self, other): return Point(self.x + other.x, self.y + other.y)","title":"M\u00e9thodes d'Op\u00e9ration Math\u00e9matique"},{"location":"poo/seance-3/methodes-speciales/#methode-__eq__","text":"La m\u00e9thode __eq__(self,other) permet de personnaliser la comparaison d'\u00e9galit\u00e9 entre deux objets de la classe.. Exemple d'utilisation : class Personne: def __init__(self, nom, age): self.nom = nom self.age = age def __eq__(self, other): return self.nom == other.nom and self.age == other.age","title":"M\u00e9thode __eq__"},{"location":"poo/seance-3/methodes-speciales/#methode-__len__","text":"La m\u00e9thode __len__ permet de personnaliser la mani\u00e8re dont la taille d'un objet est calcul\u00e9e. Exemple d'utilisation : Pour une classe de biblioth\u00e8que, vous pouvez surcharger la m\u00e9thode __len__ pour renvoyer le nombre total de livres disponibles dans cette biblioth\u00e8que. class Livre: def __init__(self, titre, auteur): self.titre = titre self.auteur = auteur class Bibliotheque: def __init__(self): self.livres = [] def ajouter_livre(self, livre): self.livres.append(livre) def __len__(self): return len(self.livres) # Cr\u00e9ez une instance de la classe Bibliotheque ma_bibliotheque = Bibliotheque() # Ajoutez des livres \u00e0 la biblioth\u00e8que livre1 = Livre(\"L'Alchimiste\", \"Paulo Coelho\") livre2 = Livre(\"1984\", \"George Orwell\") livre3 = Livre(\"Le Petit Prince\", \"Antoine de Saint-Exup\u00e9ry\") ma_bibliotheque.ajouter_livre(livre1) ma_bibliotheque.ajouter_livre(livre2) ma_bibliotheque.ajouter_livre(livre3) # Utilisation de la m\u00e9thode __len__ pour obtenir le nombre de livres dans la biblioth\u00e8que nombre_de_livres = len(ma_bibliotheque) print(\"Nombre de livres dans la biblioth\u00e8que :\", nombre_de_livres)","title":"M\u00e9thode __len__"},{"location":"poo/seance-3/methodes-speciales/#exercices","text":"Cr\u00e9ez une classe Vecteur qui repr\u00e9sente des vecteurs en 2D avec des attributs x et y. La classe doit avoir une m\u00e9thode sp\u00e9ciale __abs__ pour calculer la norme du vecteur. Rappel : La fonction abs() appliqu\u00e9e \u00e0 un vecteur en math\u00e9matiques (en particulier en g\u00e9om\u00e9trie) renvoie la norme du vecteur. La norme d'un vecteur est une mesure de sa longueur, c'est-\u00e0-dire la distance du point de d\u00e9part (origine) au point d'extr\u00e9mit\u00e9 (bout de la fl\u00e8che) du vecteur. Pour un vecteur bidimensionnel (x, y), la formule est la suivante : Norme = \u221a(x^2 + y^2) Pour un vecteur tridimensionnel (x, y, z), la formule est \u00e9tendue comme suit : Norme = \u221a(x^2 + y^2 + z^2) Solution import math class Vecteur: def __init__(self, x, y): self.x = x self.y = y def __abs__(self): return math.sqrt(self.x ** 2 + self.y ** 2) # Exemple d'utilisation v = Vecteur(3, 4) norme = abs(v) print(\"Norme du vecteur :\",norme)","title":"Exercices"},{"location":"poo/seance-3/methodes-speciales/#conclusion","text":"Les m\u00e9thodes sp\u00e9ciales en Python permettent de personnaliser le comportement des objets de vos classes. Elles facilitent l'interaction avec ces objets et rendent votre code plus lisible et plus propre. En les utilisant correctement, vous pouvez concevoir des classes plus expressives et puissantes.","title":"Conclusion"},{"location":"poo/seance-3/poo_avancee/","text":"poo_avancee.md","title":"Programmation Orient\u00e9e Objet (POO) en Python"},{"location":"rappel/chp0_Rappel/","text":"Rappel Le savoir ouvre des portes. Le premier chapitre vise \u00e0 revisiter les principales notions du langage de programmation Python qui ont \u00e9t\u00e9 \u00e9tudi\u00e9es en premi\u00e8re ann\u00e9e. S\u00e9rie de r\u00e9vision n\u00b0 1 Enonc\u00e9 et Corrig\u00e9 Enonc\u00e9 : disponible au format PDF Corrig\u00e9 : disponible au format PDF Notes du cours La fonction init re\u00e7oit l'adresse de l'argument L et l'affecte \u00e0 sa variable locale init(L) (tout param\u00e8tre d'une fonction une variable locale). Apr\u00e8s, si on fait \u00e0 l'int\u00e9rieur de la fonction L=val on change l'objet affect\u00e9 \u00e0 la variable locale L par un nouveau objet (lui aussi local \u00e0 init ). Or, la port\u00e9e de toute variable locale est limit\u00e9e \u00e0 la fonction o\u00f9 elle est d\u00e9clar\u00e9e, donc, il est n\u00e9cessaire d'utiliser return L pour exporter le contenu de cette variable locale au programme appelant (programme principal ou toute autre fonction faisant appel \u00e0 init ) Si \u00e0 l'int\u00e9rieur de la fonction, on a L[i]= valeur ou L.append(valeur) , alors il est unitile de faire return L \u00e0 la fin de la fonction pour recup\u00e9rer les modifications effectu\u00e9es a la liste L dans le programme principal. Si L est pass\u00e9e comme argument \u00e0 la fonction init et dans init(L) on a fait L=val il faut ajouter \u00e0 la fin de la fonction return L On utilise la boucle while si on a traitement r\u00e9p\u00e9tif pr\u00e9c\u00e9d\u00e9 par un test logique et dont le nombre d'it\u00e9rations est inconnu \u00e0 l'avance. Pour re-ex\u00e9cuter la ligne pr\u00e9c\u00e9dente, soit on utilise une boucle ( for ou while ),soit on cr\u00e9e une fonction r\u00e9cursive. On ajoute return devant le nom de l'appel r\u00e9cursif si le r\u00e9sultat \u00e0 retourner est cr\u00e9\u00e9 dans la fonction r\u00e9cursive. Exemples def f(): return 1 def g(): f() def h(): return f def k(a=f): return a() x = g() # x == ? y = k(h) # y == ? L = [f, g, h, k] for x in L : x()","title":"TP1 Rappel Python"},{"location":"rappel/chp0_Rappel/#rappel","text":"Le savoir ouvre des portes. Le premier chapitre vise \u00e0 revisiter les principales notions du langage de programmation Python qui ont \u00e9t\u00e9 \u00e9tudi\u00e9es en premi\u00e8re ann\u00e9e.","title":"Rappel"},{"location":"rappel/chp0_Rappel/#serie-de-revision-n-1","text":"","title":"S\u00e9rie de r\u00e9vision n\u00b0 1"},{"location":"rappel/chp0_Rappel/#enonce-et-corrige","text":"Enonc\u00e9 : disponible au format PDF Corrig\u00e9 : disponible au format PDF","title":"Enonc\u00e9 et Corrig\u00e9"},{"location":"rappel/chp0_Rappel/#notes-du-cours","text":"La fonction init re\u00e7oit l'adresse de l'argument L et l'affecte \u00e0 sa variable locale init(L) (tout param\u00e8tre d'une fonction une variable locale). Apr\u00e8s, si on fait \u00e0 l'int\u00e9rieur de la fonction L=val on change l'objet affect\u00e9 \u00e0 la variable locale L par un nouveau objet (lui aussi local \u00e0 init ). Or, la port\u00e9e de toute variable locale est limit\u00e9e \u00e0 la fonction o\u00f9 elle est d\u00e9clar\u00e9e, donc, il est n\u00e9cessaire d'utiliser return L pour exporter le contenu de cette variable locale au programme appelant (programme principal ou toute autre fonction faisant appel \u00e0 init ) Si \u00e0 l'int\u00e9rieur de la fonction, on a L[i]= valeur ou L.append(valeur) , alors il est unitile de faire return L \u00e0 la fin de la fonction pour recup\u00e9rer les modifications effectu\u00e9es a la liste L dans le programme principal. Si L est pass\u00e9e comme argument \u00e0 la fonction init et dans init(L) on a fait L=val il faut ajouter \u00e0 la fin de la fonction return L On utilise la boucle while si on a traitement r\u00e9p\u00e9tif pr\u00e9c\u00e9d\u00e9 par un test logique et dont le nombre d'it\u00e9rations est inconnu \u00e0 l'avance. Pour re-ex\u00e9cuter la ligne pr\u00e9c\u00e9dente, soit on utilise une boucle ( for ou while ),soit on cr\u00e9e une fonction r\u00e9cursive. On ajoute return devant le nom de l'appel r\u00e9cursif si le r\u00e9sultat \u00e0 retourner est cr\u00e9\u00e9 dans la fonction r\u00e9cursive.","title":"Notes du cours"},{"location":"rappel/chp0_Rappel/#exemples","text":"def f(): return 1 def g(): f() def h(): return f def k(a=f): return a() x = g() # x == ? y = k(h) # y == ? L = [f, g, h, k] for x in L : x()","title":"Exemples"}]}